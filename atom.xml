<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞码录</title>
  
  <subtitle>飞码录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codesboy.cn/"/>
  <updated>2020-06-20T15:57:21.080Z</updated>
  <id>https://www.codesboy.cn/</id>
  
  <author>
    <name>飞码录</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>447_回旋镖的数量</title>
    <link href="https://www.codesboy.cn/2020/06/20/447_%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://www.codesboy.cn/2020/06/20/447_%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2020-06-20T14:21:24.000Z</published>
    <updated>2020-06-20T15:57:21.080Z</updated>
    
    <content type="html"><![CDATA[<p>给定平面上<em>&nbsp;n </em>对不同的点，&ldquo;回旋镖&rdquo; 是由点表示的元组&nbsp;<code>(i, j, k)</code>&nbsp;，其中&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;之间的距离和&nbsp;<code>i</code>&nbsp;和&nbsp;<code>k</code>&nbsp;之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p><a id="more"></a><p>找到所有回旋镖的数量。你可以假设<em>&nbsp;n </em>最大为 <strong>500</strong>，所有点的坐标在闭区间<strong> [-10000, 10000] </strong>中。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong>[[0,0],[1,0],[2,0]]<strong>输出:</strong>2<strong>解释:</strong>两个回旋镖为 <strong>[[1,0],[0,0],[2,0]]</strong> 和 <strong>[[1,0],[2,0],[0,0]]</strong></pre><div><div>Related Topics</div><div><li>哈希表</li></div></div><br/><p>看答案才知道怎么解。初步设想的时间复杂度是O(n^3)，想想就放弃了。。。话说求距离的公式，排列组合都忘记了，敢信么。。。<br>如下解法时间复杂度是O(n^2)，空间复杂度是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(points==<span class="keyword">null</span>||points.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> distance = getDistance(points[i], points[j]);</span><br><span class="line">            map.put(distance, map.getOrDefault(distance, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : map.values()) &#123;</span><br><span class="line">            sum += val * (val - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span>[] i, <span class="keyword">int</span>[] j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = i[<span class="number">0</span>] - j[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> y = i[<span class="number">1</span>] - j[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x*x+y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200620231926.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/41#issuecomment-647002357">91算法打卡第二十天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定平面上&lt;em&gt;&amp;nbsp;n &lt;/em&gt;对不同的点，&amp;ldquo;回旋镖&amp;rdquo; 是由点表示的元组&amp;nbsp;&lt;code&gt;(i, j, k)&lt;/code&gt;&amp;nbsp;，其中&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;j&lt;/code&gt;&amp;nbsp;之间的距离和&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;之间的距离相等（&lt;strong&gt;需要考虑元组的顺序&lt;/strong&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>124_二叉树中的最大路径和</title>
    <link href="https://www.codesboy.cn/2020/06/19/124_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.codesboy.cn/2020/06/19/124_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-06-19T14:21:24.000Z</published>
    <updated>2020-06-19T16:40:51.639Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]       <strong>1</strong>      <strong>/ \</strong>     <strong>2</strong>   <strong>3</strong><strong>输出:</strong> 6</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> [-10,9,20,null,null,15,7]&nbsp;  -10&nbsp; &nbsp;/ \&nbsp; 9 &nbsp;<strong>20</strong>&nbsp; &nbsp; <strong>/ &nbsp;\</strong>&nbsp; &nbsp;<strong>15 &nbsp; 7</strong><strong>输出:</strong> 42</pre><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li></div></div><br/><p>昨晚看了答案的，今天再独立做了一次，还是比较久。。。<br>时间复杂度O(n)，<br>空间复杂度O(log(N))，堆栈的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getMaxPath(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lefMax = getMaxPath(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = getMaxPath(root.right);</span><br><span class="line">    <span class="keyword">int</span> nodeVal = root.val;</span><br><span class="line">    <span class="keyword">int</span> allPathVal = Math.max(lefMax, <span class="number">0</span>) + Math.max(rightMax, <span class="number">0</span>) + nodeVal;</span><br><span class="line">    max = Math.max(max, allPathVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodeVal + Math.max(Math.max(lefMax, rightMax), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200619234126.png" alt=""></p><p><a href="https://github.com/azl397985856/leetcode/blob/b1e1f5f55bc4ad3004cfafb6415a3e9de35c131a/problems/124.binary-tree-maximum-path-sum.md">91算法打卡第十八天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;

&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个&lt;/strong&gt;节点，且不一定经过根节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1_两数之和</title>
    <link href="https://www.codesboy.cn/2020/06/19/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.codesboy.cn/2020/06/19/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-19T14:21:24.000Z</published>
    <updated>2020-06-19T16:51:24.319Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 <code>nums</code>&nbsp;和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><a id="more"></a><p>&nbsp;</p><p><strong>示例:</strong></p><pre>给定 nums = [2, 7, 11, 15], target = 9因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9所以返回 [<strong>0, 1</strong>]</pre><div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br/><p>昨晚看了答案的，今天再独立做了一次，还是比较久。。。<br>时间复杂度O(n)，<br>空间复杂度O(log(N))，堆栈的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getMaxPath(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lefMax = getMaxPath(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = getMaxPath(root.right);</span><br><span class="line">    <span class="keyword">int</span> nodeVal = root.val;</span><br><span class="line">    <span class="keyword">int</span> allPathVal = Math.max(lefMax, <span class="number">0</span>) + Math.max(rightMax, <span class="number">0</span>) + nodeVal;</span><br><span class="line">    max = Math.max(max, allPathVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodeVal + Math.max(Math.max(lefMax, rightMax), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200619234126.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/">91算法打卡第十九天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;&amp;nbsp;和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那&amp;nbsp;&lt;strong&gt;两个&lt;/strong&gt;&amp;nbsp;整数，并返回他们的数组下标。&lt;/p&gt;

&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>105_从前序与中序遍历序列构造二叉树</title>
    <link href="https://www.codesboy.cn/2020/06/17/105_%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.codesboy.cn/2020/06/17/105_%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-06-17T14:21:24.000Z</published>
    <updated>2020-06-19T16:36:47.678Z</updated>
    
    <content type="html"><![CDATA[<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br><a id="more"></a><p>你可以假设树中没有重复的元素。</p></p><p>例如，给出</p><pre>前序遍历 preorder =&nbsp;[3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</pre><p>返回如下的二叉树：</p><pre>    3   / \  9  20    /  \   15   7</pre><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>数组</li></div></div><br/><p>看了解题思路，然后根据思路写代码。。。<br>时间复杂度O(mn)，最坏情况是O(n*n)，<br>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">    TreeNode tempHead = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="keyword">int</span> rootInOrderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inorder.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[j] == rootVal) &#123;</span><br><span class="line">            rootInOrderIndex = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] leftPreOrder = <span class="keyword">new</span> <span class="keyword">int</span>[rootInOrderIndex];</span><br><span class="line">    <span class="keyword">int</span>[] leftInOrder = <span class="keyword">new</span> <span class="keyword">int</span>[rootInOrderIndex];</span><br><span class="line">    <span class="keyword">int</span>[] rightPreOrder = <span class="keyword">new</span> <span class="keyword">int</span>[inorder.length - rootInOrderIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rightInOrder = <span class="keyword">new</span> <span class="keyword">int</span>[inorder.length - rootInOrderIndex - <span class="number">1</span>];</span><br><span class="line">    System.arraycopy(preorder, <span class="number">1</span>, leftPreOrder, <span class="number">0</span>, rootInOrderIndex);</span><br><span class="line">    System.arraycopy(inorder, <span class="number">0</span>, leftInOrder, <span class="number">0</span>, rootInOrderIndex);</span><br><span class="line">    System.arraycopy(preorder, rootInOrderIndex + <span class="number">1</span>, rightPreOrder, <span class="number">0</span>, inorder.length - rootInOrderIndex - <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(inorder, rootInOrderIndex + <span class="number">1</span>, rightInOrder, <span class="number">0</span>, inorder.length - rootInOrderIndex - <span class="number">1</span>);</span><br><span class="line">    tempHead.left = buildTree(leftPreOrder, leftInOrder);</span><br><span class="line">    tempHead.right = buildTree(rightPreOrder, rightInOrder);</span><br><span class="line">    <span class="keyword">return</span> tempHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200618020706.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">91算法打卡第十七天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>513_找树左下角的值</title>
    <link href="https://www.codesboy.cn/2020/06/17/513_%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <id>https://www.codesboy.cn/2020/06/17/513_%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</id>
    <published>2020-06-16T23:21:24.000Z</published>
    <updated>2020-06-17T18:46:44.469Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，在树的最后一行找到最左边的值。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><strong>输入:</strong>    2   / \  1   3<strong>输出:</strong>1</pre><p>&nbsp;</p><p><strong>示例 2: </strong></p><pre><strong>输入:</strong>        1       / \      2   3     /   / \    4   5   6       /      7<strong>输出:</strong>7</pre><p>&nbsp;</p><p><strong>注意:</strong> 您可以假设树（即给定的根节点）不为 <strong>NULL</strong>。</p><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li><li>广度优先搜索</li></div></div><br/><p>嗯，补作业了。昨天看了答案。<br>时间复杂度：O(N)<br>空间复杂度：O(log(N))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode tempRoot = root;</span><br><span class="line">    nodeQueue.offer(tempRoot);</span><br><span class="line">    <span class="keyword">int</span> result = tempRoot.val;</span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        TreeNode poll = nodeQueue.poll();</span><br><span class="line">        result = poll.val;</span><br><span class="line">        <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodeQueue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodeQueue.offer(poll.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200617233113.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/37#issuecomment-644840167">91算法打卡第十六天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，在树的最后一行找到最左边的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>129_求根到叶子节点数字之和</title>
    <link href="https://www.codesboy.cn/2020/06/15/129_%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.codesboy.cn/2020/06/15/129_%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-14T23:21:24.000Z</published>
    <updated>2020-06-15T17:00:22.864Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，它的每个结点都存放一个&nbsp;<code>0-9</code>&nbsp;的数字，每条从根到叶子节点的路径都代表一个数字。</p><a id="more"></a><p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]    1   / \  2   3<strong>输出:</strong> 25<strong>解释:</strong>从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>.从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>.因此，数字总和 = 12 + 13 = <code>25</code>.</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [4,9,0,5,1]    4   / \  9   0&nbsp;/ \5   1<strong>输出:</strong> 1026<strong>解释:</strong>从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495.从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491.从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40.因此，数字总和 = 495 + 491 + 40 = <code>1026</code>.</pre><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li></div></div><br/><p>今天的题看了答案才知道怎么做的，花了很长的时间唉。<br>时间复杂度O(N)，N为节点数量<br>空间复杂度O(logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = sum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSum(root.left, temp) + getSum(root.right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200616005042.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode/">91算法打卡第十五天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，它的每个结点都存放一个&amp;nbsp;&lt;code&gt;0-9&lt;/code&gt;&amp;nbsp;的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>100_相同的树</title>
    <link href="https://www.codesboy.cn/2020/06/14/100_%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://www.codesboy.cn/2020/06/14/100_%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2020-06-13T23:21:24.000Z</published>
    <updated>2020-06-14T03:44:17.394Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><a id="more"></a><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例&nbsp;1:</strong></p><pre><strong>输入: </strong>      1         1          / \       / \         2   3     2   3        [1,2,3],   [1,2,3]<strong>输出:</strong> true</pre><p><strong>示例 2:</strong></p><pre><strong>输入:  </strong>    1          1          /           \         2             2        [1,2],     [1,null,2]<strong>输出:</strong> false</pre><p><strong>示例&nbsp;3:</strong></p><pre><strong>输入:</strong>       1         1          / \       / \         2   1     1   2        [1,2,1],   [1,1,2]<strong>输出:</strong> false</pre><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li></div></div><br/><p>时间复杂度 O(N),N为节点数量，每个节点都会访问到。<br>空间复杂度：最坏情况是O(N)，比如只有左节点。最好的情况是O(log(N))，完全平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>)||(p != <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left)&amp;&amp;isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200614111527.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode/">91算法打卡第十四天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://www.codesboy.cn/2020/06/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.codesboy.cn/2020/06/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-13T10:18:24.000Z</published>
    <updated>2020-06-13T15:37:20.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p><p>比如Hibernate的SessionFactory，它就充当数据存储源的代理，并负责创建Session对象，SessionFactory并不是轻量级的，一般情况下，一个项目只需要一个SessionFactory就够了。这时就会使用到单例模式。</p><a id="more"></a><h4 id="单例设计模式七种模式"><a href="#单例设计模式七种模式" class="headerlink" title="单例设计模式七种模式"></a>单例设计模式七种模式</h4><ol><li><strong>饿汉式（静态常量）</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li><strong>懒汉式（双重检查）</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h4 id="饿汉式（静态常量）——-推荐"><a href="#饿汉式（静态常量）——-推荐" class="headerlink" title="饿汉式（静态常量）—— 推荐"></a>饿汉式（静态常量）—— 推荐</h4><p>步骤如下：</p><ol><li>构造器私有化（防止new）</li><li>类的内部创建对象</li><li>对外暴露一个静态的公共方法。getInstance</li></ol><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。getInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点如下：</p><ol><li>优点： 这种方法比较简单，就是在类加载的时候就完成实例化。避免了线程同步的问题。</li><li>缺点： 在类加载的时候就完成实例化，没有达到懒加载的效果。如果从始至终都没有用到这个实例，就会造成内存的浪费。</li><li>补充说明： 这种方法基于类加载机制避免了多线程的同步问题，不过，instance 在类加载时就实例化，在单例模式多数都是调用getInstance方法。但是导致类加载的原因有很多，因此不能确定有其他方式（或者其他静态方法）导致类加载，这时候初始化instance就没有达到懒加载的效果。</li><li>结论：这种单例模式方法可用，可能会造成内存浪费。</li></ol><h4 id="饿汉式（静态代码块）——-推荐"><a href="#饿汉式（静态代码块）——-推荐" class="headerlink" title="饿汉式（静态代码块）—— 推荐"></a>饿汉式（静态代码块）—— 推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块中，创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。getInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和上面的方式类似，只不过将类的实例化过程放在了静态代码块中，也是在类加载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面一致。</p><h4 id="懒汉式（线程不安全）——-不能使用"><a href="#懒汉式（线程不安全）——-不能使用" class="headerlink" title="懒汉式（线程不安全）—— 不能使用"></a>懒汉式（线程不安全）—— 不能使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。getInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点如下：</p><ol><li>优点： 起到了懒加载的效果，但是只能在单线程下使用。</li><li>缺点： 如果在多线程下使用，可能会产生多个实例对象。所以在多线程环境下不能使用这种方式。</li><li>结论： 实际开发中，<strong>不要使用</strong>这种方式。</li></ol><h4 id="懒汉式（线程安全，同步方法）——-不推荐"><a href="#懒汉式（线程安全，同步方法）——-不推荐" class="headerlink" title="懒汉式（线程安全，同步方法）—— 不推荐"></a>懒汉式（线程安全，同步方法）—— 不推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。getInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点如下：</p><ol><li>解决了线程安全问题</li><li>效率太低。每个线程在获得类的实例对象时，都要执行getInstance()方法进行同步。而这个方法只执行一次实例化代码就够了，后面的线程想获得该类实例，直接return就可以了。在方法上进行同步效率太低</li><li>结论：实际开发中，不推荐这种方式</li></ol><h4 id="懒汉式（双重检查）——-推荐"><a href="#懒汉式（双重检查）——-推荐" class="headerlink" title="懒汉式（双重检查）—— 推荐"></a>懒汉式（双重检查）—— 推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。getInstance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点如下：</p><ol><li>优点： 双重检查（Double-Check）概念是多线程开发中常使用的，这样子能保证线程安全。</li><li>优点： 线程安全；延迟加载；效率较高</li><li>volatile关键字确保： 当instance变量被初始化成Singleton实例时，多个线程正确处理instance变量。同时防止指令重排。volatile关键字要确保在JDK1.4版本后使用。</li><li>结论： 在实际开发中，推荐使用这种单例设计模式</li></ol><h4 id="静态内部类-——-推荐"><a href="#静态内部类-——-推荐" class="headerlink" title="静态内部类 —— 推荐"></a>静态内部类 —— 推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 构造器私有化（防止new）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写一个静态内部类，该类有一个静态属性 Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外暴露一个静态的公共方法。直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点如下：</p><ol><li>静态内部类在Singleton类被加载时并不会立即实例化，而是在需要Singleton实例时，调用getInstance方法，才会加载SingletonInstance类，从而完成静态对象INSTANCE的创建，这点同饿汉模式。</li><li>这种方式采用了类加载机制来保证初始化实例时只有一个线程。虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。如果在一个类的clinit()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行clinit()方法后，其他线程唤醒之后不会再次进入clinit()方法。同一个加载器下，一个类型只会初始化一次)，在实际应用中，这种阻塞往往是很隐蔽的。故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</li><li>优点： 避免了线程不安全，利用静态内部类的特点实现延迟加载，效率高</li><li>缺点：静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，设计单例时，我们要根据实际情况决定使用哪种方式。</li><li>结论： 在实际开发中，如果不需要传参数，推荐使用这种单例设计模式</li></ol><h4 id="枚举-——-推荐"><a href="#枚举-——-推荐" class="headerlink" title="枚举 —— 推荐"></a>枚举 —— 推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSometing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点：</p><ol><li>借助枚举来实现单例模式。不仅能避免多线程同步的问题，而且还能防止反序列化重新创建新的对象。</li><li>这种方式在《Effective Java》中提倡使用</li><li>结论： 推荐使用</li></ol><h4 id="单例模式在JDK中的应用"><a href="#单例模式在JDK中的应用" class="headerlink" title="单例模式在JDK中的应用"></a>单例模式在JDK中的应用</h4><p>在JDK中，java.lang.Runtime就是经典的单例设计模式（饿汉式（静态常量））。</p><p>代码如下：</p><p><img src="http://img.codesboy.cn/2020/06/20200613231558.png" alt=""></p><h4 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h4><ol><li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</li><li>当想实例化一个单例类时，必须要记住使用对应的获取对象的方法，比如getInstance静态方法，而不是使用new。</li><li>单例模式使用的场景：需要<strong>频繁的进行创建和销毁的对象</strong>、创建对象时耗时过多或者耗费资源过多（即重量级对象），但是又经常使用的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象（比如<strong>数据源、session工厂</strong>等）</li></ol><p>代码地址：<a href="https://github.com/GilbertXiao/JavaDesignPatterns">https://github.com/GilbertXiao/JavaDesignPatterns</a></p><br/><p>参考资源: </p><ul><li>韩顺平 《图解Java设计模式》</li><li><a href="https://blog.csdn.net/mnb65482/article/details/80458571">https://blog.csdn.net/mnb65482/article/details/80458571</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;单例模式确保一个类只有一个实例，并提供一个全局访问点。&lt;/p&gt;
&lt;p&gt;比如Hibernate的SessionFactory，它就充当数据存储源的代理，并负责创建Session对象，SessionFactory并不是轻量级的，一般情况下，一个项目只需要一个SessionFactory就够了。这时就会使用到单例模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>146_LRU缓存机制</title>
    <link href="https://www.codesboy.cn/2020/06/13/104_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://www.codesboy.cn/2020/06/13/104_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-06-12T23:21:24.000Z</published>
    <updated>2020-06-13T16:15:57.368Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><a id="more"></a><p><strong>说明:</strong>&nbsp;叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre>    3   / \  9  20    /  \   15   7</pre><p>返回它的最大深度&nbsp;3 。</p><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li></div></div><br/><p>用递归就好,</p><p><del>时间复杂度O(n)，每个节点都要遍历一次，空间复杂度O(1)，没有创建新的容器。。。</del></p><p>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。<br>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O((log(N))。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200613071925.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/">91算法打卡第十三天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;

&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>146_LRU缓存机制</title>
    <link href="https://www.codesboy.cn/2020/06/12/146_LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.codesboy.cn/2020/06/12/146_LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-06-12T13:21:24.000Z</published>
    <updated>2020-06-12T15:47:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个&nbsp; <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><a id="more"></a><p>获取数据 <code>get(key)</code> - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>&nbsp;</p><p><strong>进阶:</strong></p><p>你是否可以在&nbsp;<strong>O(1)</strong> 时间复杂度内完成这两种操作？</p><p>&nbsp;</p><p><strong>示例:</strong></p><pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得关键字 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得关键字 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</pre><div><div>Related Topics</div><div><li>设计</li></div></div><br/><p>时间复杂度O(1)，空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> capatity;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    Map&lt;Integer, Node&gt; map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capatity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (head != node) &#123;</span><br><span class="line">                removeNode(node);</span><br><span class="line">                appendHead(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> &amp;&amp; tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node existNode = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (existNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                removeNode(existNode);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.size() == capatity) &#123;</span><br><span class="line">                <span class="keyword">int</span> tailKey = tail.key;</span><br><span class="line">                removeNode(tail);</span><br><span class="line">                map.remove(tailKey);</span><br><span class="line">            &#125;</span><br><span class="line">            appendHead(node);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (head != node) &#123;</span><br><span class="line">            Node tempHead = head;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = tempHead;</span><br><span class="line">            tempHead.pre = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == head) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">                head.pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">                tail = tail.pre;</span><br><span class="line">                node.pre = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Node pre = node.pre;</span><br><span class="line">                Node next = node.next;</span><br><span class="line">                pre.next = next;</span><br><span class="line">                next.pre = pre;</span><br><span class="line">                node.pre = <span class="keyword">null</span>;</span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200612233239.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">91算法打卡第十二天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个&amp;nbsp; &lt;a href=&quot;https://baike.baidu.com/item/LRU&quot; target=&quot;_blank&quot;&gt;LRU (最近最少使用) 缓存机制&lt;/a&gt;。它应该支持以下操作： 获取数据 &lt;code&gt;get&lt;/code&gt; 和 写入数据 &lt;code&gt;put&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>142_环形链表II</title>
    <link href="https://www.codesboy.cn/2020/06/11/142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>https://www.codesboy.cn/2020/06/11/142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</id>
    <published>2020-06-11T13:21:24.000Z</published>
    <updated>2020-06-11T14:55:51.195Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;<code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><a id="more"></a><p><strong>说明：</strong>不允许修改给定的链表。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1<strong>输出：</strong>tail connects to node index 1<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</pre><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" style="height: 97px; width: 300px;"></p><p><strong>示例&nbsp;2：</strong></p><pre><strong>输入：</strong>head = [1,2], pos = 0<strong>输出：</strong>tail connects to node index 0<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</pre><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" style="height: 74px; width: 141px;"></p><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>head = [1], pos = -1<strong>输出：</strong>no cycle<strong>解释：</strong>链表中没有环。</pre><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" style="height: 45px; width: 45px;"></p><p>&nbsp;</p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><div><div>Related Topics</div><div><li>链表</li><li>双指针</li></div></div><br/><p>第一种，暴力解法：<br>时间复杂度 O(n)，空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; listNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode tempHead = head;</span><br><span class="line">        <span class="keyword">while</span> (tempHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listNodes.contains(tempHead)) &#123;</span><br><span class="line">                <span class="keyword">return</span> tempHead;</span><br><span class="line">            &#125;</span><br><span class="line">            listNodes.add(tempHead);</span><br><span class="line">            tempHead = tempHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200611215818.png" alt=""></p><p>第二种，快慢指针追及问题<br>时间复杂度 O(n)，空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fastNode.next != <span class="keyword">null</span> &amp;&amp; fastNode.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastNode = fastNode.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span> (slowNode == fastNode) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode restartNode = head;</span><br><span class="line">        <span class="keyword">while</span> (restartNode != slowNode) &#123;</span><br><span class="line">            restartNode=restartNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> restartNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200611224016.png" alt=""></p><p><a href="https://www.bilibili.com/video/BV11f4y127Se?pop_share=1">91算法打卡第十一天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。&amp;nbsp;如果链表无环，则返回&amp;nbsp;&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>160_相交链表</title>
    <link href="https://www.codesboy.cn/2020/06/10/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codesboy.cn/2020/06/10/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2020-06-10T13:21:24.000Z</published>
    <updated>2020-06-10T15:22:09.859Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p><a id="more"></a><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="height: 130px; width: 400px;"></a></p><p>在节点 c1 开始相交。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" style="height: 130px; width: 400px;"></a></p><pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<strong>输出：</strong>Reference of the node with value = 8<strong>输入解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</pre><p>&nbsp;</p><p><strong>示例&nbsp;2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" style="height: 136px; width: 350px;"></a></p><pre><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<strong>输出：</strong>Reference of the node with value = 2<strong>输入解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</pre><p>&nbsp;</p><p><strong>示例&nbsp;3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" style="height: 126px; width: 200px;"></a></p><pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<strong>输出：</strong>null<strong>输入解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<strong>解释：</strong>这两个链表不相交，因此返回 null。</pre><p>&nbsp;</p><p><strong>注意：</strong></p><ul>    <li>如果两个链表没有交点，返回 <code>null</code>.</li>    <li>在返回结果后，两个链表仍须保持原有的结构。</li>    <li>可假定整个链表结构中没有循环。</li>    <li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><div><div>Related Topics</div><div><li>链表</li></div></div><br/><p>暴力解：时间复杂度O(n),空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Map&lt;ListNode, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        ListNode tempA = headA;</span><br><span class="line">        ListNode tempB = headB;</span><br><span class="line">        <span class="keyword">while</span> (tempA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(tempA, <span class="keyword">null</span>);</span><br><span class="line">            tempA = tempA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tempB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(tempB)) &#123;</span><br><span class="line">                <span class="keyword">return</span> tempB;</span><br><span class="line">            &#125;</span><br><span class="line">            tempB = tempB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200610230507.png" alt=""></p><p>第二种思路来自群友，很巧妙的解法。假设有A由a+b组成，B由c+b组成， b为交集部分<br>那么 a+b+c=c+b+a 。以步长为1 同时遍历，最后两者相等即为交集点。<br>时间复杂度O(n),空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tempA = headA;</span><br><span class="line">        ListNode tempB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tempA != tempB) &#123;</span><br><span class="line">            tempA = tempA == <span class="keyword">null</span> ? headB : tempA.next;</span><br><span class="line">            tempB = tempB == <span class="keyword">null</span> ? headA : tempB.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200610230507.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-ha-xi-by-zstar01/">91算法打卡第十天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>109_有序链表转换二叉搜索树</title>
    <link href="https://www.codesboy.cn/2020/06/09/109_%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codesboy.cn/2020/06/09/109_%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-06-09T13:21:24.000Z</published>
    <updated>2020-06-09T17:16:07.168Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p><a id="more"></a><p><strong>示例:</strong></p><pre>给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：      0     / \   -3   9   /   / -10  5</pre><div><div>Related Topics</div><div><li>深度优先搜索</li><li>链表</li></div></div><br/><p>看答案的，自己想复杂了，对树这种结构掌握不太好。边界条件要注意。</p><p>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.integerList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeToList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.integerList.add(node.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        changeToList(head);</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode = getBST(<span class="number">0</span>, <span class="keyword">this</span>.integerList.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getBST</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = integerList.get(mid);</span><br><span class="line">        TreeNode treeNode = <span class="keyword">new</span> TreeNode(midVal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode left = getBST(start, mid-<span class="number">1</span>);</span><br><span class="line">        TreeNode right = getBST(mid+<span class="number">1</span>, end);</span><br><span class="line">        treeNode.left = left;</span><br><span class="line">        treeNode.right = right;</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200610005914.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/">91算法打卡第九天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;

&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&amp;nbsp;&lt;/em&gt;的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>430_扁平化多级双向链表</title>
    <link href="https://www.codesboy.cn/2020/06/08/430_%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codesboy.cn/2020/06/08/430_%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-06-08T13:21:24.000Z</published>
    <updated>2020-06-09T17:16:49.186Z</updated>
    
    <content type="html"><![CDATA[<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><a id="more"></a><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]<strong>解释：</strong>输入的多级列表如下图所示：<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png" style="height: 363px; width: 640px;">扁平化后的链表如下图：<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png" style="height: 80px; width: 1100px;"></pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>head = [1,2,null,3]<strong>输出：</strong>[1,3,2]<strong>解释：</strong>输入的多级列表如下图所示：  1---2---NULL  |  3---NULL</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>head = []<strong>输出：</strong>[]</pre><p>&nbsp;</p><p><strong>如何表示测试用例中的多级链表？</strong></p><p>以 <strong>示例 1</strong> 为例：</p><pre> 1---2---3---4---5---6--NULL         |         7---8---9---10--NULL             |             11--12--NULL</pre><p>序列化其中的每一级之后：</p><pre>[1,2,3,4,5,6,null][7,8,9,10,null][11,12,null]</pre><p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p><pre>[1,2,3,4,5,6,null][null,null,7,8,9,10,null][null,11,12,null]</pre><p>合并所有序列化结果，并去除末尾的 null 。</p><pre>[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>节点数目不超过 1000</li>    <li><code>1 &lt;= Node.val &lt;= 10^5</code></li></ul><div><div>Related Topics</div><div><li>深度优先搜索</li><li>链表</li></div></div><br/><p>这道题想了很久哎，最后看了答案，觉得用先序遍历最好理解。主要是多增加一个全局Node，然后先序遍历创建一个新的链表，最后把一开始的全局Node删除即可。</p><p>时间复杂度为O(n),空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node globalHead = <span class="keyword">new</span> Node();</span><br><span class="line">    Node prev = globalHead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preOrderTravel(head);</span><br><span class="line">        head = globalHead.next;</span><br><span class="line">        head.prev = <span class="keyword">null</span>;</span><br><span class="line">        globalHead.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTravel</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node child = head.child;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        head.next = head.child = <span class="keyword">null</span>;</span><br><span class="line">        prev.next = head;</span><br><span class="line">        head.prev = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        preOrderTravel(child);</span><br><span class="line">        preOrderTravel(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200609011655.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/bian-ping-hua-duo-ji-shuang-xiang-lian-biao-by-lee/">91算法打卡第八天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。&lt;/p&gt;

&lt;p&gt;给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>206_反转链表</title>
    <link href="https://www.codesboy.cn/2020/06/07/206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codesboy.cn/2020/06/07/206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-06-07T13:21:24.000Z</published>
    <updated>2020-06-08T17:16:02.587Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</pre><a id="more"></a><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><div><div>Related Topics</div><div><li>链表</li></div></div><br/><p>递归<br>递归里面还有while，时间复杂度为O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>&amp;&amp;head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode lastNode = node;</span><br><span class="line">        <span class="keyword">while</span> (lastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastNode = lastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode.next = head;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200607165952.png" alt=""></p><p>迭代：<br>可以参考讲义的内容将如下内容进行优化，时间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode tempHead = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tempHead.next = temp;</span><br><span class="line">            temp = tempHead;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200607170546.png" alt=""></p><p><a href="https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md">91算法打卡第七天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转一个单链表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
&lt;strong&gt;输出:&lt;/strong&gt; 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>合成复用原则</title>
    <link href="https://www.codesboy.cn/2020/06/07/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/"/>
    <id>https://www.codesboy.cn/2020/06/07/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</id>
    <published>2020-06-07T10:18:24.000Z</published>
    <updated>2020-06-13T15:36:13.680Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><a id="more"></a><h4 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h4><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>尽可能实现<strong>松耦合设计</strong></li></ol><h4 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h4><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ul><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ul><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ul><h4 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h4><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p><p>下面以摩托车分类管理程序为例来介绍合成复用原则的应用。</p><p>分析：摩托车按“动力源”划分可分为汽油摩托车、电动摩托车等；按“颜色”划分可分为白色摩托车、黑色摩托车和红色摩托车等。如果同时考虑这两种分类，其组合就很多。如下所示是用继承关系实现的摩托车分类的类图。</p><p><img src="http://img.codesboy.cn/2020/06/20200608004728.png" alt=""></p><p>我们可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下 所示。</p><p><img src="http://img.codesboy.cn/2020/06/20200608010553.png" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>结合前几节的内容，我们一共介绍了 7种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则。</p><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p><p>参考资源: </p><ul><li>韩顺平 《图解Java设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;原则是尽量使用合成/聚合的方式，而不是使用继承&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迪米特法则</title>
    <link href="https://www.codesboy.cn/2020/06/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    <id>https://www.codesboy.cn/2020/06/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</id>
    <published>2020-06-07T10:18:24.000Z</published>
    <updated>2020-06-13T15:36:08.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>一个对象应该对其他对象保存最少的了解</li></ol><a id="more"></a><ol start="2"><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle) 又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。</li><li>迪米特法则还有一个更加简单的定义：只与直接的朋友通信</li><li><strong>直接的朋友：</strong>每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的关系很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值</strong>中的类为直接的朋友，而<strong>出现在局部变量中的类不是直接的朋友</strong>。也是就是说，陌生的类最好不要以局部变量的形式出现在类的内部中。</li></ol><p>代码例子：</p><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id</p><h4 id="反例："><a href="#反例：" class="headerlink" title="反例："></a>反例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校的员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            CollegeEmployee collegeEmployee = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            collegeEmployee.setId(<span class="string">"学院员工id="</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">            employee.setId(<span class="string">"学校总部iD="</span>+i);</span><br><span class="line">            employees.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息（id）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmp</span><span class="params">(CollegeManager sub)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.这里的CollegeEmployee 不是SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//1.CollegeEmployee 是以局部变量的方式出现在SchoolManager中，不符合迪米特法则</span></span><br><span class="line">        <span class="comment">//获取学院的员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; allEmployee = sub.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e:allEmployee</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取学校的员工</span></span><br><span class="line">        List&lt;Employee&gt; allEmployee1 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee e :</span><br><span class="line">            allEmployee1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        schoolManager.printAllEmp(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码64行，CollegeEmployee 不是SchoolManager的直接朋友，它是以局部变量的方式出现在SchoolManager中，不符合迪米特法则。</p><h4 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h4><p>思路：我们只需要将打印学院员工编号的逻辑移到CollegeManager ，然后 SchoolManager 再调用CollegeManager的打印方法即可。这样就符合迪米特法则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//学院管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            CollegeEmployee collegeEmployee = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            collegeEmployee.setId(<span class="string">"学院员工id="</span> + i);</span><br><span class="line">            list.add(collegeEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息（id）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmp</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;CollegeEmployee&gt; allEmployee = getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e:allEmployee</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">            employee.setId(<span class="string">"学校总部iD="</span>+i);</span><br><span class="line">            employees.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息（id）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmp</span><span class="params">(CollegeManager sub)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sub.printAllEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取学校的员工</span></span><br><span class="line">        List&lt;Employee&gt; allEmployee1 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee e :</span><br><span class="line">            allEmployee1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迪米特法则注意事项和细节："><a href="#迪米特法则注意事项和细节：" class="headerlink" title="迪米特法则注意事项和细节："></a>迪米特法则注意事项和细节：</h4><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完成没有依赖关系</li></ol><p>代码地址：<a href="https://github.com/GilbertXiao/JavaDesignPatterns">https://github.com/GilbertXiao/JavaDesignPatterns</a></p><p>参考资源: </p><ul><li>韩顺平 《图解Java设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;一个对象应该对其他对象保存最少的了解&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>380_常数时间插入、删除和获取随机元素</title>
    <link href="https://www.codesboy.cn/2020/06/06/380_%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codesboy.cn/2020/06/06/380_%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</id>
    <published>2020-06-06T13:21:24.000Z</published>
    <updated>2020-06-07T09:18:00.834Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持在<em>平均&nbsp;</em>时间复杂度 <strong>O(1)</strong>&nbsp;下，执行以下操作的数据结构。</p><ol>    <li><code>insert(val)</code>：当元素 val 不存在时，向集合中插入该项。</li>    <li><code>remove(val)</code>：元素 val 存在时，从集合中移除该项。</li>    <li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有<strong>相同的概率</strong>被返回。</li></ol><a id="more"></a><p><strong>示例 :</strong></p><pre>// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom();</pre><div><div>Related Topics</div><div><li>设计</li><li>数组</li><li>哈希表</li></div></div><br/><p>有想到数组加hashmap，但是一直没想到remove掉数组中的随机某个数后，怎么很好的填补这个空缺，以及纠结这个随机数不连贯了怎么办的问题。最后无奈看了小伙伴的解答，恍然大悟，拿最后一个数去填补，而不是我一开始设想的下次insert再去填补。。。get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Integer result = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(val);</span><br><span class="line">            map.put(val, list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Integer listIndex = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (listIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(list.get(list.size() - <span class="number">1</span>), listIndex);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        list.set(listIndex, list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = random.nextInt(list.size());</span><br><span class="line">        <span class="keyword">return</span> list.get(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200607010843.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/23#issuecomment-640155651">91算法打卡第六天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持在&lt;em&gt;平均&amp;nbsp;&lt;/em&gt;时间复杂度 &lt;strong&gt;O(1)&lt;/strong&gt;&amp;nbsp;下，执行以下操作的数据结构。&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;insert(val)&lt;/code&gt;：当元素 val 不存在时，向集合中插入该项。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;remove(val)&lt;/code&gt;：元素 val 存在时，从集合中移除该项。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;getRandom&lt;/code&gt;：随机返回现有集合中的一项。每个元素应该有&lt;strong&gt;相同的概率&lt;/strong&gt;被返回。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>232_用栈实现队列</title>
    <link href="https://www.codesboy.cn/2020/06/05/232_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://www.codesboy.cn/2020/06/05/232_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-06-05T13:21:24.000Z</published>
    <updated>2020-06-05T18:05:52.039Z</updated>
    
    <content type="html"><![CDATA[<p>使用栈实现队列的下列操作：</p><ul>    <li>push(x) -- 将一个元素放入队列的尾部。</li>    <li>pop() -- 从队列首部移除元素。</li>    <li>peek() -- 返回队列首部的元素。</li>    <li>empty() -- 返回队列是否为空。</li></ul><a id="more"></a><p><strong>示例:</strong></p><pre>MyQueue queue = new MyQueue();queue.push(1);queue.push(2);  queue.peek();  // 返回 1queue.pop();   // 返回 1queue.empty(); // 返回 false</pre><p><strong>说明:</strong></p><ul>    <li>你只能使用标准的栈操作 -- 也就是只有&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;操作是合法的。</li>    <li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>    <li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><div><div>Related Topics</div><div><li>栈</li><li>设计</li></div></div><br/><p>用了两个栈，一个是对外输出栈stack（里面的元素一直符合先入先出），一个是备用栈bakStack。当push操作时，先看下stack是否为空，stack不为空则把元素push到bakStack中。当pop操作时，先把stack里面的元素pop出来，然后再判断stack是否为空，如果stack为空，这时候把bakStack的元素全部补充进stack，注意，这步操作后，stack的元素为正序，即符合先入先出了。</p><p>空间复杂度 O(n)，<br>时间复杂度 push 操作O(1)， pop 操作 O(n)，peek操作O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; bakStack;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack=<span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">this</span>.bakStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            bakStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">       <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">while</span>(!bakStack.isEmpty())&#123;</span><br><span class="line">               stack.push(bakStack.pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200605023728.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/21#issuecomment-639573715">91算法打卡第五天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;push(x) -- 将一个元素放入队列的尾部。&lt;/li&gt;
    &lt;li&gt;pop() -- 从队列首部移除元素。&lt;/li&gt;
    &lt;li&gt;peek() -- 返回队列首部的元素。&lt;/li&gt;
    &lt;li&gt;empty() -- 返回队列是否为空。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>394_字符串解码</title>
    <link href="https://www.codesboy.cn/2020/06/04/394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://www.codesboy.cn/2020/06/04/394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2020-06-04T13:21:24.000Z</published>
    <updated>2020-06-05T18:05:54.562Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><a id="more"></a><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>s = &quot;3[a]2[bc]&quot;<strong>输出：</strong>&quot;aaabcbc&quot;</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>s = &quot;3[a2[c]]&quot;<strong>输出：</strong>&quot;accaccacc&quot;</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>s = &quot;2[abc]3[cd]ef&quot;<strong>输出：</strong>&quot;abcabccdcdcdef&quot;</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>s = &quot;abc3[cd]xyz&quot;<strong>输出：</strong>&quot;abccdcdcdxyz&quot;</pre><div><div>Related Topics</div><div><li>栈</li><li>深度优先搜索</li></div></div><br/><p>这道题写了超级久，原来用了两个栈，一个队列，然后没法一条路走到黑就放弃了。群里有个人评价博主的方法聪明，从栈里面拿出来计算好再放回去栈里面，一下子点醒我。然后问题迎刃而解。谢谢小伙伴~</p><p>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String sb = <span class="string">""</span>;</span><br><span class="line">        Stack&lt;String&gt; strStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            String word = <span class="string">""</span>;</span><br><span class="line">            String repeatCount = <span class="string">""</span>;</span><br><span class="line">            StringBuilder repeatWordSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!strStack.isEmpty() &amp;&amp; !strStack.peek().equals(<span class="string">"["</span>)) &#123;</span><br><span class="line">                    word = strStack.pop().toString() + word;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (strStack.peek().equals(<span class="string">"["</span>)) &#123;</span><br><span class="line">                    strStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!strStack.isEmpty() &amp;&amp; isNumber(strStack.peek())) &#123;</span><br><span class="line">                    repeatCount = strStack.pop().toString() + repeatCount;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Integer.valueOf(repeatCount); j++) &#123;</span><br><span class="line">                    repeatWordSb.append(word);</span><br><span class="line">                &#125;</span><br><span class="line">                strStack.push(repeatWordSb.toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strStack.push(String.valueOf(chars[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!strStack.isEmpty()) &#123;</span><br><span class="line">            sb = strStack.pop() + sb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Pattern compile = Pattern.compile(<span class="string">"^[0-9]*$"</span>);</span><br><span class="line">        <span class="keyword">return</span> compile.matcher(str).matches();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加油~</p><p><img src="http://img.codesboy.cn/2020/06/20200605012145.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/20#issuecomment-638800071">91算法打卡第四天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;

&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 &lt;em&gt;encoded_string&lt;/em&gt; 正好重复 &lt;em&gt;k&lt;/em&gt; 次。注意 &lt;em&gt;k&lt;/em&gt; 保证为正整数。&lt;/p&gt;

&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
