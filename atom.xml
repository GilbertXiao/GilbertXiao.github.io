<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞码录</title>
  
  <subtitle>飞码录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codesboy.cn/"/>
  <updated>2020-07-08T18:12:24.711Z</updated>
  <id>https://www.codesboy.cn/</id>
  
  <author>
    <name>飞码录</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表</title>
    <link href="https://www.codesboy.cn/2020/07/08/92_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>https://www.codesboy.cn/2020/07/08/92_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</id>
    <published>2020-07-08T15:21:24.000Z</published>
    <updated>2020-07-08T18:12:24.711Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><p><strong>示例:</strong></p><a id="more"></a><pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</pre><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><div><div>Related Topics</div><div><li>链表</li></div></div><br/><p>方法1——迭代<br>时间复杂度O(n)，<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">   ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode tempHead = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        tempHead.next = temp;</span><br><span class="line">        temp = tempHead;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200708211619.png" alt=""></p><p>方法2——递归<br>时间复杂度O(n)，<br>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ListNode last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    reverse(head);</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = head;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tempHead = head.next;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    reverse(tempHead);</span><br><span class="line">    tempHead.next = head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200708213503.png" alt=""></p><br><hr><br><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 &le;&nbsp;<em>m</em>&nbsp;&le;&nbsp;<em>n</em>&nbsp;&le; 链表长度。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4<strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</pre><div><div>Related Topics</div><div><li>链表</li></div></div><br/><p>迭代</p><p>思路：记录位置m-1的listnode A和 n+1 的 listnode B , 翻转 m-n 的子链表，得到翻转后的子链表的 head listnode C 和 tail listnode D ，然后 A -&gt;C -&gt; D -&gt;B </p><p>时间复杂度O(n)，<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    ListNode top = head;</span><br><span class="line">    <span class="comment">//reverse children listnode</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//disreverse  listnode left index</span></span><br><span class="line">    ListNode left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//disreverse  listnode right index</span></span><br><span class="line">    ListNode right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//reverse children listnode right index</span></span><br><span class="line">    ListNode innerRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == m - <span class="number">1</span> &amp;&amp; m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            left = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == n + <span class="number">1</span>) &#123;</span><br><span class="line">            right = head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= m &amp;&amp; index &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == m) &#123;</span><br><span class="line">                innerRight = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head.next = temp;</span><br><span class="line">            temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (innerRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">        innerRight.next = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200708225611.png" alt=""></p><br><hr><br><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><p>给你一个链表，每&nbsp;<em>k&nbsp;</em>个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k&nbsp;</em>是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是&nbsp;<em>k&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>&nbsp;</p><p><strong>示例：</strong></p><p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>当&nbsp;<em>k&nbsp;</em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>当&nbsp;<em>k&nbsp;</em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>&nbsp;</p><p><strong>说明：</strong></p><ul>    <li>你的算法只能使用常数的额外空间。</li>    <li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><div><div>Related Topics</div><div><li>链表</li></div></div><br><p>迭代 </p><p>思路：每k个一组翻转，分为偶数组和奇数组，当偶数组时，就把前面的奇数组的最后一个next 改成 当前偶数组的 head，当奇数组时，就把前面的偶数组的最后一个next 改成 当前奇数组的 head。</p><p>(reverseCount &amp; 1) == 0 用来判断是否为偶数，方法来自小灰算法。</p><p>时间复杂度O(n)，<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">ListNode oddReverseChildHead = <span class="keyword">null</span>;</span><br><span class="line">ListNode oddReverseChildTail = <span class="keyword">null</span>;</span><br><span class="line">ListNode evenReverseChildHead = <span class="keyword">null</span>;</span><br><span class="line">ListNode evenReverseChildTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> reverseCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode childHead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode top = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> firstFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode tempHead = head.next;</span><br><span class="line">        <span class="keyword">if</span> (index % k == <span class="number">0</span>) &#123;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            reverseChild(childHead);</span><br><span class="line">            <span class="keyword">if</span> (firstFlag) &#123;</span><br><span class="line">                top = head;</span><br><span class="line">                firstFlag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((reverseCount &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">//is even</span></span><br><span class="line">                oddReverseChildTail.next = evenReverseChildHead;</span><br><span class="line">                oddReverseChildHead = <span class="keyword">null</span>;</span><br><span class="line">                oddReverseChildTail = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (evenReverseChildHead != <span class="keyword">null</span>) &#123; <span class="comment">// is old</span></span><br><span class="line">                    evenReverseChildTail.next = oddReverseChildHead;</span><br><span class="line">                    evenReverseChildHead = <span class="keyword">null</span>;</span><br><span class="line">                    evenReverseChildTail = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            childHead = <span class="keyword">null</span>;</span><br><span class="line">            reverseCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index % k == <span class="number">1</span>) &#123;</span><br><span class="line">            childHead = head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = tempHead;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((reverseCount &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// is even</span></span><br><span class="line">        oddReverseChildTail.next = childHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// is odd</span></span><br><span class="line">        evenReverseChildTail.next = childHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseChild</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode top = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode tempHead = head.next;</span><br><span class="line">        head.next = top;</span><br><span class="line">        top = head;</span><br><span class="line">        head = tempHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((reverseCount &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;  <span class="comment">// is even</span></span><br><span class="line">        evenReverseChildHead = top;</span><br><span class="line">        evenReverseChildTail = tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//is odd</span></span><br><span class="line">        oddReverseChildHead = top;</span><br><span class="line">        oddReverseChildTail = tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200709005556.png" alt=""></p><p><a href="https://github.com/azl397985856/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups-cn.md">91算法打卡第三十八天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转一个单链表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>20. 有效的括号 | 32. 最长有效括号</title>
    <link href="https://www.codesboy.cn/2020/07/07/20_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://www.codesboy.cn/2020/07/07/20_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-07-07T15:21:24.000Z</published>
    <updated>2020-07-08T18:20:18.702Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code>&nbsp;的字符串，判断字符串是否有效。</p><a id="more"></a><p>有效字符串需满足：</p><ol>    <li>左括号必须用相同类型的右括号闭合。</li>    <li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> &quot;()&quot;<strong>输出:</strong> true</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> &quot;()[]{}&quot;<strong>输出:</strong> true</pre><p><strong>示例&nbsp;3:</strong></p><pre><strong>输入:</strong> &quot;(]&quot;<strong>输出:</strong> false</pre><p><strong>示例&nbsp;4:</strong></p><pre><strong>输入:</strong> &quot;([)]&quot;<strong>输出:</strong> false</pre><p><strong>示例&nbsp;5:</strong></p><pre><strong>输入:</strong> &quot;{[]}&quot;<strong>输出:</strong> true</pre><div><div>Related Topics</div><div><li>栈</li><li>字符串</li></div></div><br/><p>第一种思路，用栈解答<br>时间复杂度O(n)，<br>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Character&gt; chars = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>||s.charAt(i)==<span class="string">'['</span>||s.charAt(i)==<span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            chars.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chars.size() == <span class="number">0</span> || getCharMapping(chars.pop()) != s.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chars.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCharMapping</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">')'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">']'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&#125;'</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200707220650.png" alt=""></p><p>第二种思路用正则，<br>时间复杂度O(n)，<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s.contains(<span class="string">"&#123;&#125;"</span>) || s.contains(<span class="string">"[]"</span>) || s.contains(<span class="string">"()"</span>)) &#123;</span><br><span class="line">        s = s.replaceAll(<span class="string">"\\&#123;&#125;"</span> , <span class="string">""</span>);</span><br><span class="line">        s = s.replaceAll(<span class="string">"\\[]"</span> , <span class="string">""</span>);</span><br><span class="line">        s = s.replace(<span class="string">"()"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200707220752.png" alt=""></p><br><hr><br><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><p>给定一个只包含 <code>&#39;(&#39;</code>&nbsp;和 <code>&#39;)&#39;</code>&nbsp;的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例&nbsp;1:</strong></p><pre><strong>输入:</strong> &quot;(()&quot;<strong>输出:</strong> 2<strong>解释:</strong> 最长有效括号子串为 <code>&quot;()&quot;</code></pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> &quot;<code>)()())</code>&quot;<strong>输出:</strong> 4<strong>解释:</strong> 最长有效括号子串为 <code>&quot;()()&quot;</code></pre><div><div>Related Topics</div><div><li>字符串</li><li>动态规划</li></div></div><br><p><a href="https://github.com/azl397985856/leetcode/blob/master/problems/32.longest-valid-parentheses.md">91算法打卡第三十七天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt;&amp;nbsp;的字符串，判断字符串是否有效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="https://www.codesboy.cn/2020/07/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.codesboy.cn/2020/07/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-07T10:18:24.000Z</published>
    <updated>2020-07-08T00:29:23.943Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文之前，请先阅读《工厂方法模式》一文。</p><p>引文：</p><pre><code>《工厂方法模式》一文的披萨项目又迎来重大升级了。现在披萨产品可以放各式各样的定制食材，如下图。</code></pre><p><img src="http://img.codesboy.cn/2020/07/20200707235236.png" alt=""></p><a id="more"></a><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>每一个模式都是针对一定问题的解决方案。抽象工厂模式面对的问题是多个产品等级结构的设计。</li><li>抽象工厂模式提供一个接口，用来创建相关或依赖<strong>对象的家族</strong>，而不需要明确指定具体类。</li><li>抽象工厂模式是工厂方法模式的升级版，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构。</li></ol><h3 id="抽象工厂模式的组成"><a href="#抽象工厂模式的组成" class="headerlink" title="抽象工厂模式的组成"></a>抽象工厂模式的组成</h3><p><img src="http://img.codesboy.cn/2020/07/20200708080305.png" alt=""></p><p>与工厂方法模式一样，使用抽象工厂模式的系统涉及以下的角色：</p><ul><li>抽象工厂(Creator)角色：抽象工厂模式的核心，与应用程序无关。任何在抽象工厂模式中创建对象的工厂类 必须实现这个接口或者实现这个抽象类(如果抽象工厂角色是由抽象类实现的话)。</li><li>具体工厂(Concrete Creator) 角色：它含有与应用相关的逻辑，并且受到应用程序的调用从而创建产品对象。</li><li>抽象产品(Product)角色：它是抽象工厂模式所创建的对象的超类型，具体产品继承的父类或者是实现的接口。</li><li>具体产品(Concrete Product) 角色: 这个角色实现了抽象产品角色所声明的接口。抽象工厂模式所创建的每一个对象都是某个具体产品角色的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。</li></ul><h3 id="代码思路分析-类图"><a href="#代码思路分析-类图" class="headerlink" title="代码思路分析(类图)"></a>代码思路分析(类图)</h3><br/><p>参考资源: </p><ul><li>韩顺平 《图解Java设计模式》</li><li>《Java与模式》</li><li>《Head first 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读本文之前，请先阅读《工厂方法模式》一文。&lt;/p&gt;
&lt;p&gt;引文：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;《工厂方法模式》一文的披萨项目又迎来重大升级了。现在披萨产品可以放各式各样的定制食材，如下图。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://img.codesboy.cn/2020/07/20200707235236.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="https://www.codesboy.cn/2020/07/06/62_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.codesboy.cn/2020/07/06/62_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-06T15:21:24.000Z</published>
    <updated>2020-07-08T18:00:38.292Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。</p><a id="more"></a><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png"></p><p><small>例如，上图是一个7 x 3 的网格。有多少可能的路径？</small></p><p>&nbsp;</p><p><strong>示例&nbsp;1:</strong></p><pre><strong>输入:</strong> m = 3, n = 2<strong>输出:</strong> 3<strong>解释:</strong>从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> m = 7, n = 3<strong>输出:</strong> 28</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= m, n &lt;= 100</code></li>    <li>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></li></ul><div><div>Related Topics</div><div><li>数组</li><li>动态规划</li></div></div><br/><p>第一种方法超时：<br>时间复杂度O(2^max(m,n))<br>空间复杂度O(max(m,n)),递归的最大深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniquePaths(m - <span class="number">1</span>, n) + uniquePaths(m, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下方法是看了群友的思路：<br>第二种方法：</p><p>时间复杂度O(m*n)</p><p>空间复杂度O(m*n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] array= <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    array[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[i][j] = array[i][j - <span class="number">1</span>] + array[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200706234144.png" alt=""></p><p>第三种方法，空间优化：</p><p>时间复杂度O(m*n)</p><p>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] last= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    last[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cur[j] = last[j] + cur[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        last=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200707000249.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/61#issuecomment-654016803">91算法打卡第三十六天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n &lt;/em&gt;网格的左上角 （起始点在下图中标记为&amp;ldquo;Start&amp;rdquo; ）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>78. 子集</title>
    <link href="https://www.codesboy.cn/2020/07/05/78_%E5%AD%90%E9%9B%86/"/>
    <id>https://www.codesboy.cn/2020/07/05/78_%E5%AD%90%E9%9B%86/</id>
    <published>2020-07-05T15:21:24.000Z</published>
    <updated>2020-07-06T00:30:15.130Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组<strong>不含重复元素</strong>的整数数组&nbsp;<em>nums</em>，返回该数组所有可能的子集（幂集）。</p><a id="more"></a><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> nums = [1,2,3]<strong>输出:</strong>[  [3],&nbsp; [1],&nbsp; [2],&nbsp; [1,2,3],&nbsp; [1,3],&nbsp; [2,3],&nbsp; [1,2],&nbsp; []]</pre><div><div>Related Topics</div><div><li>位运算</li><li>数组</li><li>回溯算法</li></div></div><br/><p>暴力解法，没想到执行时间能超过那么多人。<br>伪代码思路如下：</p><ol><li>创建全局的list，用于存所有的组合。</li><li>首先在list 放入一个空数组</li><li>遍历整个nums：<br> 每遍历到一个num，就把list的所有的组合拿出来，复制一份，然后每个复制的组合再加上这个num，存入list中。</li><li>返回list</li></ol><p>时间复杂度 O(2^n - 1)<br>空间复杂度 O(2^(n-1))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;Integer&gt; nulList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(nulList);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; tempList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; subList : list) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">            integers.add(nums[i]);</span><br><span class="line">            tempList.add(integers);</span><br><span class="line">        &#125;</span><br><span class="line">        list.addAll(tempList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200705123855.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/60#issuecomment-653883996">91算法打卡第三十五天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组&amp;nbsp;&lt;em&gt;nums&lt;/em&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="https://www.codesboy.cn/2020/07/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.codesboy.cn/2020/07/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-05T10:18:24.000Z</published>
    <updated>2020-07-07T23:37:26.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三种工厂模式基本介绍"><a href="#三种工厂模式基本介绍" class="headerlink" title="三种工厂模式基本介绍"></a>三种工厂模式基本介绍</h3><p>在创建类时，通常可以同时定义多个构造函数，然后让它们创建类的实例。然而，有的时候，客户代码虽然需要某个对象，却并不关心或者不需要关心这个对象究竟是由哪个类创建而来的，此时就可以使用工厂模式。</p><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><a id="more"></a><p>工厂模式在《Java与模式》中分为三类：</p><ol><li>简单工厂模式(Simple Factory)</li><li>工厂方法模式(Factory Method)</li><li>抽象工厂模式(Abstract Factory)</li></ol><p>这三种模式从上到下逐步抽象，并且更具一般性。</p><p>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式(Factory Method) 与抽象工厂模式 (Abstract Factory) 。将简单工厂模式(Simple Factory)看成 工厂方法模式的一种特例，两者归为一类。</p><p>这两种都可以。本文使用《Java与模式》的方法，不过将简单工厂模式归在工厂方法模式一文中介绍。</p><h3 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式(Simple Factory)"></a>简单工厂模式(Simple Factory)</h3><p>引文：</p><pre><code>有一个披萨的项目，要便于披萨种类的扩展，便于维护。1. 披萨的种类很多，比如GreekPizza、CheesePizza等2. 披萨的制作有 prepare、bake、cut、box3. 完成披萨店订购功能</code></pre><h4 id="使用传统方式完成"><a href="#使用传统方式完成" class="headerlink" title="使用传统方式完成"></a>使用传统方式完成</h4><ol><li>思路分析(类图)</li></ol><p><img src="http://img.codesboy.cn/2020/07/20200705222202.png" alt=""></p><p>编写一个OrderPizza类，去订购需要的各种Pizza</p><ol start="2"><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，不同的披萨不一样，因此，我们做成抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" banking..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" cutting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" boxing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 给制作奶酪披萨 准备原材料 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 给希腊披萨 准备原材料 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHEESE_PIZZA = <span class="string">"cheese"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GREEK_PIZZA = <span class="string">"greek"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (CHEESE_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GREEK_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>传统方式的优缺点：</li></ol><p>1)优点是比较好理解，简单易操作。<br>2)缺点是违反了设计模式的开闭原则(OCP),即当我们给类增加新功能时，尽可能不修改客户端的代码 。<br>比如，当我们增加一个Pizza类，只要是订购Pizza的代码都需要修改。</p><p><img src="http://img.codesboy.cn/2020/07/20200705223855.png" alt=""></p><p>2)改进思路分析</p><p>如果有多个客户端采用如上的方式订购了Pizza,那么意味着只要新增或修改了Pizza类，多个客户端都需要做改动，否则报错。</p><p>改进：把创建Pizza对象封装到一个类中，这样我们有新的Pizz种类时，只需要修改该类即可。其他创建Pizza对象的代码就不需要修改了。这就是简单工厂模式的应用。</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><ol><li>基本介绍： 简单工厂模式又称静态工厂方法模式，是工厂方法模式的一种特殊实现，也是工厂模式家族中最简单实用的模式。结构如下：<br><img src="http://img.codesboy.cn/2020/07/20200706004617.png" alt=""></li></ol><ol start="2"><li>代码演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHEESE_PIZZA = <span class="string">"cheese"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GREEK_PIZZA = <span class="string">"greek"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PEPPER_PIZZA = <span class="string">"pepper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (CHEESE_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GREEK_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PEPPER_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SimpleFactory simpleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = simpleFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Pizza pizza ;</span><br><span class="line">        pizza = simpleFactory.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>优缺点：</li></ol><p>1)优点： 简单工厂模式实现了对责任的分割。即工厂类专注于对产品类的创建，而客户端则不用直接创建产品对象，仅仅负责“消费”产品。</p><p>2)缺点：</p><pre><code>当产品类有复杂的多层次等级结构时，工厂类只有它自己。以不变应万变，这是缺点之一。工厂类集中了所有产品的创建逻辑，是一个无所不知的全能类。当该类不能正常工作时，所有产品都会受到影响。简单工厂方法只是一定程度上支持开闭原则，比如每次有新增的产品类，客户端不用做修改，这符合开闭原则，但是工厂类就需要修改以适用变化，这一块就不符合开闭原则了。</code></pre><ol start="4"><li><p>源码应用：</p><p>JDK中java.text.DateFormat 的 如下方法使用了简单工厂模式：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>, style, <span class="number">2</span>, Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h3><p>引文：</p><pre><code>披萨项目升级，需要各个不同地区口味的披萨，比如芝加哥风味的CheesePizza、芝加哥风味的greekPizza，纽约风味的CheesePizza、纽约风味的greekPizza。</code></pre><p>思路一：</p><p>使用简单工厂模式， 创建不同的简单工厂类， 比如 ChicagoPizzaSimpleFactory、 NYPizzaSimpleFactory 等等。从当前这个案例来说， 也是可以的， 但是考虑到项目的规模， 以及软件的可维护性、 可扩展性并不是特别好</p><p>思路二：</p><p>使用工厂方法模式。</p><ol><li><p>工厂方法模式的引进：</p><p> 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><p> 首先，在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做，这个核心类则变成一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p></li><li><p>工厂方法模式的组成：</p></li></ol><p><img src="http://img.codesboy.cn/2020/07/20200708073607.png" alt=""></p><p>从上图可以看出，使用工厂方法模式的系统涉及以下的角色：</p><ul><li>抽象工厂(Creator)角色：工厂方法模式的核心，与应用程序无关。任何在工厂方法模式中创建对象的工厂类 必须实现这个接口或者实现这个抽象类(如果抽象工厂角色是由抽象类实现的话)。</li><li>具体工厂(Concrete Creator) 角色：它含有与应用相关的逻辑，并且受到应用程序的调用从而创建产品对象。</li><li>抽象产品(Product)角色：它是工厂方法模式所创建的对象的超类型，具体产品继承的父类或者是实现的接口。</li><li>具体产品(Concrete Product) 角色: 这个角色实现了抽象产品角色所声明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。</li></ul><ol start="3"><li>代码思路分析(类图)：</li></ol><p><img src="http://img.codesboy.cn/2020/07/20200708073716.png" alt=""></p><ol start="4"><li>代码演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">implements</span> <span class="title">PizzaStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHEESE_PIZZA = <span class="string">"cheese"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GREEK_PIZZA = <span class="string">"greek"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PEPPER_PIZZA = <span class="string">"pepper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (CHEESE_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoGreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GREEK_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoGreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PEPPER_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoPepperPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">implements</span> <span class="title">PizzaStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHEESE_PIZZA = <span class="string">"cheese"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GREEK_PIZZA = <span class="string">"greek"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PEPPER_PIZZA = <span class="string">"pepper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (CHEESE_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> NYGreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GREEK_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> NYGreekPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PEPPER_PIZZA.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> NYPepperPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，不同的披萨不一样，因此，我们做成抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" banking..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" cutting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" boxing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChicagoCheesePizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.name = <span class="string">"ChicagoCheesePizza"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 给制作ChicagoCheesePizza 准备原材料 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NYCheesePizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.name = <span class="string">"NYCheesePizza"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">" 给制作NYCheesePizza 准备原材料 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PizzaStore pizzaStore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(PizzaStore pizzaStore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pizzaStore = pizzaStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Pizza pizza ;</span><br><span class="line">        pizza = pizzaStore.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderPizza orderPizza = <span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> NYPizzaStore());</span><br><span class="line">        Pizza cheese = orderPizza.orderPizza(<span class="string">"cheese"</span>);</span><br><span class="line"></span><br><span class="line">        OrderPizza orderPizza1 = <span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> ChicagoPizzaStore());</span><br><span class="line">        Pizza cheese1 = orderPizza1.orderPizza(<span class="string">"cheese"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>工厂方法在源码中的应用：</li></ol><ul><li>Collection 接口为抽象工厂类，工厂方法为iterator()方法，返回一个Iterator类型的对象（抽象产品）。</li><li>List接口为抽象工厂类，工厂方法为listIterator()方法，返回一个ListIterator类型的对象（抽象产品）。</li></ul><p>工厂方法模式VS简单工厂模式：</p><ol><li>由上面我们可以看出在结构上两者区别是很明显的。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体的类上。工厂方法模式可以允许很多具体工厂类从抽象工厂类中将创建行为继承下来，从而可以成为多个简单工厂模式的综合。</li><li>工厂方法模式退化后可以变得很像简单工厂模式。如果确定系统里面只需要一个具体工厂类，不妨可以把抽象工厂类合并到具体工厂类，再不妨把工厂方法改成静态，从而得到简单工厂模式。</li><li>理想情况下，系统增加一个产品，那么只需要向系统增加这个这个产品类及对应的工厂类，没有改变客户端，也没有改变抽象工厂角色或者其他已有的具体工厂类。这完全支持开闭原则。</li></ol><br/><p>参考资源: </p><ul><li>韩顺平 《图解Java设计模式》</li><li>《Java与模式》</li><li>《Head first 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;三种工厂模式基本介绍&quot;&gt;&lt;a href=&quot;#三种工厂模式基本介绍&quot; class=&quot;headerlink&quot; title=&quot;三种工厂模式基本介绍&quot;&gt;&lt;/a&gt;三种工厂模式基本介绍&lt;/h3&gt;&lt;p&gt;在创建类时，通常可以同时定义多个构造函数，然后让它们创建类的实例。然而，有的时候，客户代码虽然需要某个对象，却并不关心或者不需要关心这个对象究竟是由哪个类创建而来的，此时就可以使用工厂模式。&lt;/p&gt;
&lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.codesboy.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="https://www.codesboy.cn/2020/07/04/581_%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codesboy.cn/2020/07/04/581_%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-04T15:21:24.000Z</published>
    <updated>2020-07-06T00:27:32.362Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><a id="more"></a><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [2, 6, 4, 8, 10, 9, 15]<strong>输出:</strong> 5<strong>解释:</strong> 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</pre><p><strong>说明 :</strong></p><ol>    <li>输入的数组长度范围在&nbsp;[1, 10,000]。</li>    <li>输入的数组可能包含<strong>重复</strong>元素&nbsp;，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><div><div>Related Topics</div><div><li>数组</li></div></div><br/><p>暴力思路：<br>这是我原先的思路，只顾着找右边界，每次找到符合条件的右边界，就暴力找左边界。<br>时间复杂度O(n^2)<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> start = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempMax &gt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    start = Math.min(j, start);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempMax = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200704191205.png" alt=""></p><p>优化思路：<br>这个思路是看群友的，用的双指针，找右边界的同时，找左边界。<br>时间复杂度O(n)<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; nums[i]) &#123;</span><br><span class="line">            end = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min &lt; nums[right]) &#123;</span><br><span class="line">            start = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end &gt; <span class="number">0</span> ? end - start + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/07/20200704195330.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/59#issuecomment-653435975">91算法打卡第三十四天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组，你需要寻找一个&lt;strong&gt;连续的子数组&lt;/strong&gt;，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题 17.11. 单词距离</title>
    <link href="https://www.codesboy.cn/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%9817_11_%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/"/>
    <id>https://www.codesboy.cn/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%9817_11_%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-06-30T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:55.419Z</updated>
    
    <content type="html"><![CDATA[<p>有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p><a id="more"></a><p><strong>示例：</strong></p><pre><strong>输入：</strong>words = [&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,&quot;from&quot;,&quot;a&quot;,&quot;university&quot;,&quot;in&quot;,&quot;a&quot;,&quot;city&quot;], word1 = &quot;a&quot;, word2 = &quot;student&quot;<strong>输出：</strong>1</pre><p>提示：</p><ul>    <li><code>words.length &lt;= 100000</code></li></ul><div><div>Related Topics</div><div><li>双指针</li><li>字符串</li></div></div><br/><p>第一种方法的伪代码：</p><ol><li><p>先遍历数组，当数组中的值等于word1或word2，就创建一个pair，key为当前值，value为当前值的索引，然后放入list中。</p></li><li><p>获取list的第一个元素，记做pre。初始化最小差值minPath，值初始化为超大超大那种。。。</p><p>跳过list的第一个元素，从第二个元素开始遍历：</p><pre><code>记当前的遍历元素为cur当pre的key和cur的key 不一样，得出pre和cur的value 差值 path，并与minPath求最小值，赋值到minPath。cur赋值给pre继续循环。</code></pre></li><li><p>返回minPath</p></li></ol><p>时间复杂度O(n),<br>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">    List&lt;Pair&gt; pairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.equals(words[i]) || word2.equals(words[i])) &#123;</span><br><span class="line">            Pair&lt;String, Integer&gt; stringIntegerPair = <span class="keyword">new</span> Pair&lt;String, Integer&gt;(words[i], i);</span><br><span class="line">            pairs.add(stringIntegerPair);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pairs.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> minPath;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair prePair = pairs.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line">        Pair curPair = pairs.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!prePair.getKey().equals(curPair.getKey())) &#123;</span><br><span class="line">            <span class="keyword">int</span> path = Math.abs((<span class="keyword">int</span>) curPair.getValue() - (<span class="keyword">int</span>) prePair.getValue());</span><br><span class="line">            minPath = Math.min(path, minPath);</span><br><span class="line">        &#125;</span><br><span class="line">        prePair = curPair;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200630230511.png" alt=""></p><p>第二种方法是看题解的，看了之后觉得我的第一种方法有点多此一举，其实可以不需要维护list的。。。</p><p>时间复杂度O(n),<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">    Integer word1Index = <span class="keyword">null</span>;</span><br><span class="line">    Integer word2Index = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.equals(words[i])) &#123;</span><br><span class="line">            word1Index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (word2.equals(words[i])) &#123;</span><br><span class="line">            word2Index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (word1Index != <span class="keyword">null</span> &amp;&amp; word2Index != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPath=Math.min(minPath,Math.abs(word1Index-word2Index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200630232110.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/58#issuecomment-651732786">91算法打卡第三十天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>42. 接雨水</title>
    <link href="https://www.codesboy.cn/2020/06/29/42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://www.codesboy.cn/2020/06/29/42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-06-29T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:46.336Z</updated>
    
    <content type="html"><![CDATA[<p>给定&nbsp;<em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><a id="more"></a><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" style="height: 161px; width: 412px;"></p><p><small>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。&nbsp;<strong>感谢 Marcos</strong> 贡献此图。</small></p><p><strong>示例:</strong></p><pre><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<strong>输出:</strong> 6</pre><div><div>Related Topics</div><div><li>栈</li><li>数组</li><li>双指针</li></div></div><br/><p>看了<a href="https://github.com/leetcode-pp/91alg-1/issues/57#issuecomment-651045232">小漾童鞋</a>的伪代码思路才恍然大悟的。</p><p>伪代码如下：</p><ol><li><p>初始化左右指针left、right指向数组头尾；</p></li><li><p>初始化左最大高度maxleft=0,右最大高度maxRight =0</p></li><li><p>当left &lt; = right 重复以下循环：</p><pre><code>当左高度height[left] &lt; 右高度height[right]    此时关注点在左指针这边，因为它目前为低高度，能不能盛水取决于这边    当左最大高度maxleft&lt; 左高度height[left]         此时盛不了水，就令左最大高度maxleft= 左高度height[left]    否则         可以盛水，sum+=maxleft-height[left]    left++ 否则     此时关注点在右指针这边，因为它目前为低高度，能不能盛水取决于这边     当右最大高度maxRight&lt; 右高度height[right]          此时盛不了水，就令右最大高度maxRight= 右高度height[right]     否则         可以盛水，sum+=maxRight-height[right]     right--</code></pre></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxleft &lt; height[left]) &#123;</span><br><span class="line">                maxleft = height[left];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += maxleft - height[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxRight &lt; height[right]) &#123;</span><br><span class="line">                maxRight = height[right];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += maxRight - height[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200629234459.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/57#issuecomment-651000402">91算法打卡第二十九天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定&amp;nbsp;&lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>167. 两数之和II-输入有序数组</title>
    <link href="https://www.codesboy.cn/2020/06/28/167_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codesboy.cn/2020/06/28/167_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-28T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:37.426Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个已按照<strong><em>升序排列</em>&nbsp;</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值<em> </em>index1 和 index2，其中 index1&nbsp;必须小于&nbsp;index2<em>。</em></p><a id="more"></a><p><strong>说明:</strong></p><ul>    <li>返回的下标值（index1 和 index2）不是从零开始的。</li>    <li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><pre><strong>输入:</strong> numbers = [2, 7, 11, 15], target = 9<strong>输出:</strong> [1,2]<strong>解释:</strong> 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</pre><div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>二分查找</li></div></div><br/><p>一开始想到的是，leetcode第一道题的解法，<br>时间复杂度O(n)，<br>空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; integerIntegerHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    integerIntegerHashMap.put(numbers[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (integerIntegerHashMap.containsKey(target - numbers[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;integerIntegerHashMap.get(target - numbers[i]), i + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        integerIntegerHashMap.put(numbers[i], i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200628233107.png" alt=""></p><p>这次主题是双指针，当然也要用双指针尝试下，leetcode上第二种方法比第一种方法速度快了很多。应该是第一种方法中的map的containsKey方法拖慢了速度，我记得这个方法的时间复杂度是近似O(1)<br>时间复杂度O(n),<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200628234233.png" alt=""></p><p><a href="https://github.com/azl397985856/leetcode/blob/master/problems/167.two-sum-ii-input-array-is-sorted.md">91算法打卡第二十八天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个已按照&lt;strong&gt;&lt;em&gt;升序排列&lt;/em&gt;&amp;nbsp;&lt;/strong&gt;的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;

&lt;p&gt;函数应该返回这两个下标值&lt;em&gt; &lt;/em&gt;index1 和 index2，其中 index1&amp;nbsp;必须小于&amp;nbsp;index2&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>26. 删除排序数组中的重复项</title>
    <link href="https://www.codesboy.cn/2020/06/27/26_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://www.codesboy.cn/2020/06/27/26_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2020-06-27T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:27.210Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p><p>&nbsp;</p><p><strong>示例&nbsp;1:</strong></p><pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, 函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong>。 你不需要考虑数组中超出新长度后面的元素。</pre><p><strong>示例&nbsp;2:</strong></p><pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong>。你不需要考虑数组中超出新长度后面的元素。</pre><p>&nbsp;</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre>// <strong>nums</strong> 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);}</pre><div><div>Related Topics</div><div><li>数组</li><li>双指针</li></div></div><br/><p>以前做过这道题，现在才知道是快慢指针。<br>时间复杂度O(n)，<br>空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preNum != nums[i]) &#123;</span><br><span class="line">                nums[++newIndex] = nums[i];</span><br><span class="line">                preNum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newIndex+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200627112047.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/54#issuecomment-650523049">91算法打卡第二十七天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在&lt;strong&gt;&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt; 原地&lt;/a&gt;&lt;/strong&gt; 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>875. 爱吃香蕉的珂珂</title>
    <link href="https://www.codesboy.cn/2020/06/26/875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <id>https://www.codesboy.cn/2020/06/26/875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</id>
    <published>2020-06-26T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:14.925Z</updated>
    
    <content type="html"><![CDATA[<p>珂珂喜欢吃香蕉。这里有&nbsp;<code>N</code>&nbsp;堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在&nbsp;<code>H</code>&nbsp;小时后回来。</p><a id="more"></a><p>珂珂可以决定她吃香蕉的速度&nbsp;<code>K</code>&nbsp;（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>K</code> 根。如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>H</code> 小时内吃掉所有香蕉的最小速度 <code>K</code>（<code>K</code> 为整数）。</p><p>&nbsp;</p><ul></ul><p><strong>示例 1：</strong></p><pre><strong>输入: </strong>piles = [3,6,7,11], H = 8<strong>输出: </strong>4</pre><p><strong>示例&nbsp;2：</strong></p><pre><strong>输入: </strong>piles = [30,11,23,4,20], H = 5<strong>输出: </strong>30</pre><p><strong>示例&nbsp;3：</strong></p><pre><strong>输入: </strong>piles = [30,11,23,4,20], H = 6<strong>输出: </strong>23</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= piles.length &lt;= 10^4</code></li>    <li><code>piles.length &lt;= H &lt;= 10^9</code></li>    <li><code>1 &lt;= piles[i] &lt;= 10^9</code></li></ul><div><div>Related Topics</div><div><li>二分查找</li></div></div><br/><p>用二分法。直到max&gt;min这个条件不符合，结束循环。<br>时间复杂度：O(nlogN)，N为一开始min-max的范围，n为piles的个数<br>空间复杂度：O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; piles.length; i++) &#123;</span><br><span class="line">            max = Math.max(piles[i], max);</span><br><span class="line">            sum += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        min = (<span class="keyword">int</span>) Math.ceil(sum / H);</span><br><span class="line">        <span class="keyword">while</span> (min &lt; max) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.ceil((min + max) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> needHours = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; piles.length; i++) &#123;</span><br><span class="line">                needHours+=(<span class="keyword">int</span>) Math.ceil((<span class="keyword">double</span>)piles[i]/mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needHours &gt; H) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min == mid) &#123;</span><br><span class="line">                    min = mid = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    min = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200626213519.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/52#issuecomment-650155495">91算法打卡第二十六天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;珂珂喜欢吃香蕉。这里有&amp;nbsp;&lt;code&gt;N&lt;/code&gt;&amp;nbsp;堆香蕉，第 &lt;code&gt;i&lt;/code&gt; 堆中有&amp;nbsp;&lt;code&gt;piles[i]&lt;/code&gt;&amp;nbsp;根香蕉。警卫已经离开了，将在&amp;nbsp;&lt;code&gt;H&lt;/code&gt;&amp;nbsp;小时后回来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="https://www.codesboy.cn/2020/06/25/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://www.codesboy.cn/2020/06/25/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-06-25T15:21:24.000Z</published>
    <updated>2020-06-30T16:35:03.376Z</updated>
    
    <content type="html"><![CDATA[<p>给你 <em>n</em> 个非负整数 <em>a</em><sub>1</sub>，<em>a</em><sub>2，</sub>...，<em>a</em><sub>n，</sub>每个数代表坐标中的一个点&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em>&nbsp;的两个端点分别为&nbsp;(<em>i</em>,&nbsp;<em>a<sub>i</sub></em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与&nbsp;<em>x</em>&nbsp;轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><p><strong>说明：</strong>你不能倾斜容器，且&nbsp;<em>n</em>&nbsp;的值至少为 2。</p><p>&nbsp;</p><p><img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" style="height: 287px; width: 600px;"></p><p><small>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</small></p><p>&nbsp;</p><p><strong>示例：</strong></p><pre><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<strong>输出：</strong>49</pre><div><div>Related Topics</div><div><li>数组</li><li>双指针</li></div></div><br/><p>一开始的思路是两个for循环，时间复杂度O(n^2),空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(height[i], height[j]);</span><br><span class="line">            <span class="keyword">int</span> bottom = j - i;</span><br><span class="line">            <span class="keyword">int</span> area = bottom * min;</span><br><span class="line">            max = Math.max(area, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200625143011.png" alt=""></p><p>后面看了题解，嗯，双指针原来是这样的，我以为我的方法也是双指针。。。<br>时间复杂度O(n),空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> area = Math.min(height[left],height[right])*(right-left);</span><br><span class="line">        max = Math.max(area, max);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200625145622.png" alt=""></p><p>祝大家端午安康~</p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/51#issuecomment-649502160">91算法打卡第二十五天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你 &lt;em&gt;n&lt;/em&gt; 个非负整数 &lt;em&gt;a&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;，&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;2，&lt;/sub&gt;...，&lt;em&gt;a&lt;/em&gt;&lt;sub&gt;n，&lt;/sub&gt;每个数代表坐标中的一个点&amp;nbsp;(&lt;em&gt;i&lt;/em&gt;,&amp;nbsp;&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;) 。在坐标内画 &lt;em&gt;n&lt;/em&gt; 条垂直线，垂直线 &lt;em&gt;i&lt;/em&gt;&amp;nbsp;的两个端点分别为&amp;nbsp;(&lt;em&gt;i&lt;/em&gt;,&amp;nbsp;&lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;) 和 (&lt;em&gt;i&lt;/em&gt;, 0)。找出其中的两条线，使得它们与&amp;nbsp;&lt;em&gt;x&lt;/em&gt;&amp;nbsp;轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>149. 直线上最多的点</title>
    <link href="https://www.codesboy.cn/2020/06/24/149_%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9/"/>
    <id>https://www.codesboy.cn/2020/06/24/149_%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9/</id>
    <published>2020-06-24T15:21:24.000Z</published>
    <updated>2020-06-30T16:34:53.140Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维平面，平面上有&nbsp;<em>n&nbsp;</em>个点，求最多有多少个点在同一条直线上。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [[1,1],[2,2],[3,3]]<strong>输出:</strong> 3<strong>解释:</strong>^|| &nbsp; &nbsp; &nbsp; &nbsp;o| &nbsp; &nbsp; o| &nbsp;o &nbsp;+-------------&gt;0 &nbsp;1 &nbsp;2 &nbsp;3  4</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<strong>输出:</strong> 4<strong>解释:</strong>^||  o| &nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp;      o| &nbsp;&nbsp;&nbsp;&nbsp;   o| &nbsp;o &nbsp;      o+-------------------&gt;0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6</pre><div><div>Related Topics</div><div><li>哈希表</li><li>数学</li></div></div><br/><p>一开始的思路时间复杂度是O(n^2)，觉得不太可能，就看了宝石的答案和官网题解，发现还真是。。。<br>时间复杂度 O(n^2) 嵌套for循环<br>空间复杂度O(n) n为点的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public int maxPoints(int[][] points) &#123;</span><br><span class="line">    if (points &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (points.length &lt;&#x3D; 2) &#123;</span><br><span class="line">        return points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; points.length; i++) &#123;</span><br><span class="line">        int same &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; points.length; j++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int x &#x3D; points[j][0] - points[i][0];</span><br><span class="line">            int y &#x3D; points[j][1] - points[i][1];</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                same++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int greatestCommonDivisor &#x3D; gcd(y, x);</span><br><span class="line">            String key &#x3D; &quot;&quot; + y &#x2F; greatestCommonDivisor + &#39;#&#39; + x &#x2F; greatestCommonDivisor;</span><br><span class="line">            Integer value &#x3D; map.getOrDefault(key, 0) + 1;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.isEmpty()) &#123;</span><br><span class="line">            max &#x3D; Math.max(max, same);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Integer value : map.values()) &#123;</span><br><span class="line">                max &#x3D; Math.max(max, same + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int gcd(int y, int x) &#123;</span><br><span class="line">    if (y &#x3D;&#x3D; x || x &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    if (y &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    if (y &#x2F; x &lt; 0) &#123;</span><br><span class="line">        if (y &gt; 0) &#123;</span><br><span class="line">            return -gcd(y, -x);</span><br><span class="line">        &#125;</span><br><span class="line">        return gcd(-y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((y &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; (x &amp; 1) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return gcd(y &gt;&gt; 1, x &gt;&gt; 1) &lt;&lt; 1;</span><br><span class="line">    &#125; else if ((y &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; (x &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">        return gcd(y &gt;&gt; 1, x);</span><br><span class="line">    &#125; else if ((y &amp; 1) !&#x3D; 0 &amp;&amp; (x &amp; 1) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return gcd(y, x &gt;&gt; 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int bigger &#x3D; y &gt; x ? y : x;</span><br><span class="line">        int smaller &#x3D; y &gt; x ? x : y;</span><br><span class="line">        return gcd(bigger - smaller, smaller);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcd 借鉴了小灰漫画算法里面的。优化% 取余的效率，可是最后和宝石的时间对比竟然还要差。。。</p><p><img src="http://img.codesboy.cn/2020/06/20200625014425.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/50#issuecomment-648820744">91算法打卡第二十四天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维平面，平面上有&amp;nbsp;&lt;em&gt;n&amp;nbsp;&lt;/em&gt;个点，求最多有多少个点在同一条直线上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题 04.01. 节点间通路</title>
    <link href="https://www.codesboy.cn/2020/06/24/%E9%9D%A2%E8%AF%95%E9%A2%980401_%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/"/>
    <id>https://www.codesboy.cn/2020/06/24/%E9%9D%A2%E8%AF%95%E9%A2%980401_%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/</id>
    <published>2020-06-24T14:21:24.000Z</published>
    <updated>2020-06-30T16:34:41.761Z</updated>
    
    <content type="html"><![CDATA[<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p><a id="more"></a><p><strong>示例1:</strong></p><pre><strong> 输入</strong>：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2<strong> 输出</strong>：true</pre><p><strong>示例2:</strong></p><pre><strong> 输入</strong>：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4<strong> 输出</strong> true</pre><p><strong>提示：</strong></p><ol>    <li>节点数量n在[0, 1e5]范围内。</li>    <li>节点编号大于等于 0 小于 n。</li>    <li>图中可能存在自环和平行边。</li></ol><div><div>Related Topics</div><div><li>图</li></div></div><br/><p>昨天看了宝石的题解，今天再自己做出来了，fighting。<br>用了邻接表+DFS<br>时间复杂度：<br>构建邻接表：O(n) n为边的总数<br>DFS：O(n+m)  n为去除平行边和自环边的总数，m为点数<br>空间复杂度：<br>visited数组：O(m) m为点数<br>邻接表：O(n+m)  n为去除自环边的总数，m为点数<br>dfs：O(m) 递归栈的最大深度，m为点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; integerSetMap ;</span><br><span class="line">BitSet bitSet;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferMapFromGraph</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">    integerSetMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] edge = graph[i];</span><br><span class="line">        Set&lt;Integer&gt; pointSet = integerSetMap.getOrDefault(edge[<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        pointSet.add(edge[<span class="number">1</span>]);</span><br><span class="line">        integerSetMap.put(edge[<span class="number">0</span>], pointSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!integerSetMap.containsKey(start))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitSet.set(start);</span><br><span class="line">    Set&lt;Integer&gt; pointSet = integerSetMap.get(start);</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = pointSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer next = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(next==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bitSet.get(next))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs(next, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transferMapFromGraph(graph);</span><br><span class="line">    bitSet = <span class="keyword">new</span> BitSet(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(start, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200624225759.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/45#issuecomment-648178243">91算法打卡第二十三天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>645. 错误的集合</title>
    <link href="https://www.codesboy.cn/2020/06/22/645_%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>https://www.codesboy.cn/2020/06/22/645_%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</id>
    <published>2020-06-22T14:21:24.000Z</published>
    <updated>2020-06-30T16:34:02.742Z</updated>
    
    <content type="html"><![CDATA[<p>集合 <code>S</code> 包含从1到&nbsp;<code>n</code>&nbsp;的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p><a id="more"></a><p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> nums = [1,2,2,4]<strong>输出:</strong> [2,3]</pre><p><strong>注意:</strong></p><ol>    <li>给定数组的长度范围是&nbsp;[2, 10000]。</li>    <li>给定的数组是无序的。</li></ol><div><div>Related Topics</div><div><li>哈希表</li><li>数学</li></div></div><br/><p>有考虑异或，但没想出来。<br>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span> doubleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lostNum = <span class="number">0</span>;</span><br><span class="line">    BitSet bitSet = <span class="keyword">new</span> BitSet(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitSet.get(nums[i])) &#123;</span><br><span class="line">            doubleNum = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bitSet.set(nums[i],<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bitSet.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bitSet.get(i)) &#123;</span><br><span class="line">            lostNum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lostNum == <span class="number">0</span>) &#123;</span><br><span class="line">        lostNum=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;doubleNum, lostNum&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200622232012.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/set-mismatch/solution/cuo-wu-de-ji-he-by-leetcode/">91算法打卡第二十二天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合 &lt;code&gt;S&lt;/code&gt; 包含从1到&amp;nbsp;&lt;code&gt;n&lt;/code&gt;&amp;nbsp;的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>36. 有效的数独</title>
    <link href="https://www.codesboy.cn/2020/06/21/36_%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://www.codesboy.cn/2020/06/21/36_%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</id>
    <published>2020-06-21T14:21:24.000Z</published>
    <updated>2020-06-30T16:33:39.707Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个&nbsp;9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><a id="more"></a><ol>    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>    <li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。</li></ol><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" style="height: 250px; width: 250px;"></p><p><small>上图是一个部分填充的有效的数独。</small></p><p>数独部分空格内已填入了数字，空白格用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p><p><strong>示例&nbsp;1:</strong></p><pre><strong>输入:</strong>[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]<strong>输出:</strong> true</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong>[&nbsp; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&nbsp; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&nbsp; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],&nbsp; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],&nbsp; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],&nbsp; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],&nbsp; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]<strong>输出:</strong> false<strong>解释:</strong> 除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre><p><strong>说明:</strong></p><ul>    <li>一个有效的数独（部分已被填充）不一定是可解的。</li>    <li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>    <li>给定数独序列只包含数字&nbsp;<code>1-9</code>&nbsp;和字符&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>    <li>给定数独永远是&nbsp;<code>9x9</code>&nbsp;形式的。</li></ul><div><div>Related Topics</div><div><li>哈希表</li></div></div><br/><p>一次遍历所有的数，并每次都做判断：<br>时间复杂度O(n^2)<br>空间复杂度O(1)。<br>不过貌似时间很长。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Set&lt;Integer&gt;[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">            String val = String.valueOf(board[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"."</span>.equalsIgnoreCase(val)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Integer&gt;[] sets = map.get(val);</span><br><span class="line">            Integer area = getArea(i, j);</span><br><span class="line">            <span class="keyword">if</span> (sets != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sets[<span class="number">0</span>].contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sets[<span class="number">1</span>].contains(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sets[<span class="number">2</span>].contains(area)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sets[<span class="number">0</span>].add(i);</span><br><span class="line">                sets[<span class="number">1</span>].add(j);</span><br><span class="line">                sets[<span class="number">2</span>].add(area);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashSet&lt;Integer&gt; rowSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            HashSet&lt;Integer&gt; columnSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            HashSet&lt;Integer&gt; areaSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            rowSet.add(i);</span><br><span class="line">            columnSet.add(j);</span><br><span class="line">            areaSet.add(area);</span><br><span class="line">            Set&lt;Integer&gt;[] setsArray = <span class="keyword">new</span> HashSet[]&#123;rowSet, columnSet, areaSet&#125;;</span><br><span class="line">            map.put(val, setsArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = i / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = j / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    <span class="keyword">char</span>[][] mathLogic = &#123;</span><br><span class="line">        &#123;<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'.'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">boolean</span> validSudoku = solution.isValidSudoku(mathLogic);</span><br><span class="line">    System.out.println(validSudoku);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200621141123.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/43#issuecomment-647124518">91算法打卡第二十一天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个&amp;nbsp;9x9 的数独是否有效。只需要&lt;strong&gt;根据以下规则&lt;/strong&gt;，验证已经填入的数字是否有效即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>447. 回旋镖的数量</title>
    <link href="https://www.codesboy.cn/2020/06/20/447_%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://www.codesboy.cn/2020/06/20/447_%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2020-06-20T14:21:24.000Z</published>
    <updated>2020-06-30T16:33:26.912Z</updated>
    
    <content type="html"><![CDATA[<p>给定平面上<em>&nbsp;n </em>对不同的点，&ldquo;回旋镖&rdquo; 是由点表示的元组&nbsp;<code>(i, j, k)</code>&nbsp;，其中&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;之间的距离和&nbsp;<code>i</code>&nbsp;和&nbsp;<code>k</code>&nbsp;之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p><a id="more"></a><p>找到所有回旋镖的数量。你可以假设<em>&nbsp;n </em>最大为 <strong>500</strong>，所有点的坐标在闭区间<strong> [-10000, 10000] </strong>中。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong>[[0,0],[1,0],[2,0]]<strong>输出:</strong>2<strong>解释:</strong>两个回旋镖为 <strong>[[1,0],[0,0],[2,0]]</strong> 和 <strong>[[1,0],[2,0],[0,0]]</strong></pre><div><div>Related Topics</div><div><li>哈希表</li></div></div><br/><p>看答案才知道怎么解。初步设想的时间复杂度是O(n^3)，想想就放弃了。。。话说求距离的公式，排列组合都忘记了，敢信么。。。<br>如下解法时间复杂度是O(n^2)，空间复杂度是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(points==<span class="keyword">null</span>||points.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> distance = getDistance(points[i], points[j]);</span><br><span class="line">            map.put(distance, map.getOrDefault(distance, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : map.values()) &#123;</span><br><span class="line">            sum += val * (val - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span>[] i, <span class="keyword">int</span>[] j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = i[<span class="number">0</span>] - j[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> y = i[<span class="number">1</span>] - j[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x*x+y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200620231926.png" alt=""></p><p><a href="https://github.com/leetcode-pp/91alg-1/issues/41#issuecomment-647002357">91算法打卡第二十天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定平面上&lt;em&gt;&amp;nbsp;n &lt;/em&gt;对不同的点，&amp;ldquo;回旋镖&amp;rdquo; 是由点表示的元组&amp;nbsp;&lt;code&gt;(i, j, k)&lt;/code&gt;&amp;nbsp;，其中&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;j&lt;/code&gt;&amp;nbsp;之间的距离和&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;之间的距离相等（&lt;strong&gt;需要考虑元组的顺序&lt;/strong&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="https://www.codesboy.cn/2020/06/19/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.codesboy.cn/2020/06/19/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-06-19T14:21:24.000Z</published>
    <updated>2020-06-30T16:33:16.832Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 <code>nums</code>&nbsp;和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><a id="more"></a><p>&nbsp;</p><p><strong>示例:</strong></p><pre>给定 nums = [2, 7, 11, 15], target = 9因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9所以返回 [<strong>0, 1</strong>]</pre><div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br/><p>昨晚看了答案的，今天再独立做了一次，还是比较久。。。<br>时间复杂度O(n)，<br>空间复杂度O(log(N))，堆栈的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getMaxPath(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lefMax = getMaxPath(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = getMaxPath(root.right);</span><br><span class="line">    <span class="keyword">int</span> nodeVal = root.val;</span><br><span class="line">    <span class="keyword">int</span> allPathVal = Math.max(lefMax, <span class="number">0</span>) + Math.max(rightMax, <span class="number">0</span>) + nodeVal;</span><br><span class="line">    max = Math.max(max, allPathVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodeVal + Math.max(Math.max(lefMax, rightMax), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200619234126.png" alt=""></p><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/">91算法打卡第十九天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;&amp;nbsp;和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那&amp;nbsp;&lt;strong&gt;两个&lt;/strong&gt;&amp;nbsp;整数，并返回他们的数组下标。&lt;/p&gt;

&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>124. 二叉树中的最大路径和</title>
    <link href="https://www.codesboy.cn/2020/06/19/124_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.codesboy.cn/2020/06/19/124_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2020-06-19T14:21:24.000Z</published>
    <updated>2020-06-30T16:33:06.367Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><a id="more"></a><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]       <strong>1</strong>      <strong>/ \</strong>     <strong>2</strong>   <strong>3</strong><strong>输出:</strong> 6</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> [-10,9,20,null,null,15,7]&nbsp;  -10&nbsp; &nbsp;/ \&nbsp; 9 &nbsp;<strong>20</strong>&nbsp; &nbsp; <strong>/ &nbsp;\</strong>&nbsp; &nbsp;<strong>15 &nbsp; 7</strong><strong>输出:</strong> 42</pre><div><div>Related Topics</div><div><li>树</li><li>深度优先搜索</li></div></div><br/><p>昨晚看了答案的，今天再独立做了一次，还是比较久。。。<br>时间复杂度O(n)，<br>空间复杂度O(log(N))，堆栈的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getMaxPath(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lefMax = getMaxPath(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = getMaxPath(root.right);</span><br><span class="line">    <span class="keyword">int</span> nodeVal = root.val;</span><br><span class="line">    <span class="keyword">int</span> allPathVal = Math.max(lefMax, <span class="number">0</span>) + Math.max(rightMax, <span class="number">0</span>) + nodeVal;</span><br><span class="line">    max = Math.max(max, allPathVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodeVal + Math.max(Math.max(lefMax, rightMax), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.codesboy.cn/2020/06/20200619234126.png" alt=""></p><p><a href="https://github.com/azl397985856/leetcode/blob/b1e1f5f55bc4ad3004cfafb6415a3e9de35c131a/problems/124.binary-tree-maximum-path-sum.md">91算法打卡第十八天参考答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;

&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个&lt;/strong&gt;节点，且不一定经过根节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="刷算法题" scheme="https://www.codesboy.cn/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
