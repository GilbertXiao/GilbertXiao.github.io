{"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"刷算法题 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 算法前言 刷题前述 1 数组_53最大子序和 给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/algorithm/index.html"},{"title":"","text":"源码 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 Tomcat8.5.50源码环境搭建 学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/code-source/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"设计模式 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 设计模式(顺序已经整理好) 1 设计模式前言 软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 1 单一职责原则 对类来说，即一个类只负责一项职责。 1 接口隔离原则 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 1 依赖倒转原则 细节应该依赖抽象; 依赖倒转(倒置)的本质是面向接口编程 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/designPattern/index.html"}],"posts":[{"title":"Tomcat8.5.50源码环境搭建","text":"学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 1. 首先到tomcat官网下载 src 和 部署包。 2. 下载后解压src 包和 bin包。3. 在src包中添加pom.xml文件，引入需要的依赖。 在pom.xml添加如下配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5&lt;/name&gt; &lt;version&gt;8.5&lt;/version&gt; &lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--Tomcat是java开发的，封装了很多新功能，它需要依赖一些基础的jar包--&gt; &lt;dependencies&gt; &lt;!--远程过程调用工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--soap协议处理工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt; &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--解析webservice的wsdl文件工具--&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eclipse Java编译器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--ant管理工具--&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--easymock辅助单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 启动idea，导入该项目，并将它转成maven工程。 5. tomcat是一个java se工程，在config中配置启动类： 其中，vm option的具体配置如下： 1234-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties 6. 保存好。如果现在启动会因为jsp没有解析报错，所以需要添加jsp 的解析，如下：在ContextConfig的类中configureStart 方法添加 初始化jsp解析引擎： 1234//位置：package org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:788) //初始化jsp解析引擎-japser context.addServletContainerInitializer(new JasperInitializer(), null); 7. 启动tomcat ,可以访问到tomcat的页面了。控制台乱码解决杰哥总结了3种方法，读者按需配置： 设置语言环境： 在如上的第6步的vm option 添加如下配置，将环境改成英文环境，避免乱码: 1234567-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties-Dfile.encoding=UTF-8-Duser.language=en-Duser.region=US 修改如下两个地方的编码： pom 的jdk 修改成11，并做好jdk11 的环境安装配置(未尝试) 1234567891011121314151617181920212223&lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","link":"/2020/05/13/Tomcat8.5.50%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"依赖倒转原则","text":"基本介绍 依赖倒转原则(Dependence Inversion Principle)是指： 细节应该依赖抽象 依赖倒转(倒置)的本质是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 反例：123456789101112131415161718192021public class Sms { public String getMsg(){ return \"hello world\"; }}public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 如上Mobile类的receiveMsg方法参数是具体的对象Sms，如果以后还需要接收其他类型的数据，比如微信等，需要重新写方法，非常不利于扩展，改动大。 正例：改成面向接口对象即可。 123456789101112131415161718192021222324252627282930313233343536public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用案例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 构造方法传递 1234567891011121314151617181920212223242526272829303132333435363738public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; public DuckFly(Run run) { this.run = run; } @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(quickRun); duckFly.flyHigh(); }} setter 方法传递(较少使用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); } public Run getRun() { return run; } public void setRun(Run run) { this.run = run; }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); DuckFly duckFly = new DuckFly(); duckFly.setRun(quickRun); duckFly.flyHigh(); }} 依赖倒转原则的注意事项和细节 低层模块最好有接口或者实现类，这样程序稳定性好 变量的声明尽量是抽象类或者方法，这样变量引用和实际对象间有了一个缓冲，利于程序的扩展和优化 比如我们方法参数常用List 而不是ArrayList，这样当我们需要LinkedList的时候，方法不需要改变什么就可以直接使用了。 继承时要遵循里氏替换原则（下节内容） 解释：每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/19/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/"},{"title":"数组_53最大子序和","text":"给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 Related Topics数组分治算法动态规划 这道题花了两个小时。各种考虑不周。其实三天前就看了答案的，知道有负收益这回事，但是真到了码代码就出错了。 1234567891011121314151617181920212223242526class Solution { public int maxSubArray(int[] nums) { //记录目前出现的最大的和 int max = nums[0]; //连续求和 int sum = 0; //一开始就赋值nums[0]，并循环从下标为1 的开始，导致漏了这种情况 [-1,2,3],无经验的表现。 for (int i = 0; i &lt; nums.length; i++) { sum+=nums[i]; //一旦sum小于等于0，就是无收益，放弃这个子数组，准备重新取值 if (sum &lt;= 0) { if(nums[i]&gt;0){ //nums[i]还是正收益，取该值 sum=nums[i]; }else { //nums[i]&lt;=0,从下个开始取 sum=0; } max = Math.max(nums[i], max); }else { max = Math.max(sum, max); } } return max; }} 看题解，思路更易懂些： 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for(int num: nums) { if(sum &gt; 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }}","link":"/2020/05/20/%E6%95%B0%E7%BB%84_53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"单一职责原则","text":"基本介绍： 对类来说，即一个类只负责一项职责。如类A 负责两个不同职责： 职责1，职责2。当职责1 需求变更而改变A时，可能会造成职责2执行错误，所以需要将类A的粒度分解成A1，A2 反例：12345678910111213141516171819202122232425262728public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路上面跑\"); }}public class SingleResponsibility1 { //方式1 的run方法违反单一职责原则 //解决的方案非常简单，根据交通工具运行方式不同，分解不同类即可。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.run(\"飞机\"); //wrong }} 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class RoadVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在公路运行\"); }}public class AirVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在空中运行\"); }}public class WaterVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility2 { //方式2 遵守了单一职责，但是这样的改动很大，即将类分解，同时修改客户端。 public static void main(String[] args) { RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run(\"摩托车\"); roadVehicle.run(\"汽车\"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run(\"飞机\"); WaterVehicle waterVehicle = new WaterVehicle(); waterVehicle.run(\"潜水艇\"); }} 改进：12345678910111213141516171819202122232425262728293031323334353637383940public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路运行\"); } public void runAir (String vehicle){ System.out.println(vehicle+\"在天空运行\"); } public void runWater (String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility3 { //方式3 只是增加了方法。虽然没有类这个级别上遵守单一职责原则，但是在方法的级别上，仍然准备单一职责原则的。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.runAir(\"飞机\"); }} 注意细节事项和细节： 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则的；只有类中方法数量足够少，才可以在方法级别保持单一职责原则。 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/15/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"},{"title":"接口隔离原则","text":"基本介绍 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 改造前：改造前，如下UML图所示 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public interface Interface1 {​ void operation1();​ void operation2();​ void operation3();​ void operation4();​ void operation5();}public class B implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"B 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"B 实现了operation5\");​ }}public class D implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"D 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"D 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend2(Interface1 inteface1){​ inteface1.operation2();​ }​ public void depend3(Interface1 inteface1){​ inteface1.operation3();​ }}public class C {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend4(Interface1 inteface1){​ inteface1.operation4();​ }​ public void depend5(Interface1 inteface1){​ inteface1.operation5();​ }} 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D。如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。 按照接口隔离原则应当如下处理： 将接口Interface1拆分成几个接口（这里我们拆分成3个接口），类Ａ和类Ｃ分别与他们需要的接口建立依赖关系。 改造后：改进的UML类图如下： 改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public interface Interface1 {​ void operation1();}public interface Interface2 {​ void operation2();​ void operation3();}public interface Interface3 {​ void operation4();​ void operation5();}public class B implements Interface1,Interface2 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }}public class D implements Interface1,Interface3 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend2(Interface2 inteface){​ inteface.operation2();​ }​ public void depend3(Interface2 inteface){​ inteface.operation3();​ }}public class C {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend4(Interface3 inteface){​ inteface.operation4();​ }​ public void depend5(Interface3 inteface){​ inteface.operation5();​ }} 测试代码如下： 12345678910111213141516171819202122public static void main(String[] args) {​ A a = new A();​ a.depend1(new B()); //A 类通过接口去依赖(使用)B​ a.depend2(new B());​ a.depend3(new B());​ C c = new C();​ c.depend1(new D());//C 类通过接口去依赖(使用)D​ c.depend4(new D());​ c.depend5(new D());​ } 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/17/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"},{"title":"算法前言","text":"根据up主小齐的经验，她的第一阶段是根据MIT的算法导论课的课程顺序调整Leetcode的刷题顺序的，如下就是该课程的排课表： 截止到目前[20200519]，杰哥已经刷了13道题了（easy难度，题号从小到大的排序），还是比较弱鸡的。杰哥也会根据这个排课表重新调整刷题顺序的，需要继续努力啊，少年。 第一阶段刷题： 数组： Leetcode no.53 最大子序和 Leetcode no.66 加1 待更新","link":"/2020/05/19/%E7%AE%97%E6%B3%95%E5%89%8D%E8%A8%80/"},{"title":"依赖倒转原则","text":"基本介绍： 依赖倒转原则（Dependence Inversion Principle）是指： 细节应该依赖于抽象 本质上是面向接口编程 依赖倒转是基于这样的设计理念： 相对于细节的多变性，抽象的东西要稳定得多。在Java中,抽象是指接口或者抽象类，细节就是对应的实现类 使用接口或者抽象类的目的在于制定好规范，不涉及任何的具体实现。把需要具体操作的任务交给他们对应的实现类去进行。 反例：123456789101112131415161718192021public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Sms { public String getMsg(){ return \"hello world\"; }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 分析： Mobile类的receiveMsg方法参数直接面向具体对象，如果以后该Mobile对象还需接收其他类型的数据，比如彩信之类的，扩展非常不方便。 正例：我们面向接口编程即可解决这样扩展的需求： 1234567891011121314151617181920212223242526272829303132333435public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用实例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 2. 构造方法传递3. setter 方法传递","link":"/2020/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E8%A8%80/"}],"tags":[{"name":"tomcat源码","slug":"tomcat源码","link":"/tags/tomcat%E6%BA%90%E7%A0%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"刷算法题","slug":"刷算法题","link":"/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"}],"categories":[{"name":"tomcat源码","slug":"tomcat源码","link":"/categories/tomcat%E6%BA%90%E7%A0%81/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"刷算法题","slug":"刷算法题","link":"/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"}]}