{"pages":[{"title":"","text":"源码 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 Tomcat8.5.50源码环境搭建 学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/code-source/index.html"},{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"漫画算法 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 漫画算法(顺序已经整理好) 1 漫画算法 漫画算法 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/readings/ComicAlgorithm.html"},{"title":"","text":"设计模式 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 设计模式(顺序已经整理好) 1 设计模式前言 软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 1 单一职责原则 对类来说，即一个类只负责一项职责。 1 接口隔离原则 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 1 依赖倒转原则 细节应该依赖抽象; 依赖倒转(倒置)的本质是面向接口编程 1 里氏替换原则 子类中尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 1 开闭原则 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 1 迪米特法则 一个对象应该对其他对象保存最少的了解 1 合成复用原则 尽量使用合成/聚合的方式，而不是使用继承 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/designPattern/index.html"},{"title":"","text":"刷算法题 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 算法前言 刷题前述 1 数组_53最大子序和 给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和 1 数组_66加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 1 数组_88合并两个有序数组 给你两个有序整数数组nums1和 nums2，请你将 nums2 合并到nums1中，使 nums1成为一个有序数组。 1 66_加一 为什么又是加一？因为这是加入算法组织的第一天出的题~ 1 75_颜色分类 给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 1 1381_设计一个支持增量操作的栈 实现自定义栈类 1 394_字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。 1 232_用栈实现队 用栈实现队 1 380_常数时间插入、删除和获取随机元素 常数时间插入、删除和获取随机元素 1 206_反转链表 反转链表 1 430_扁平化多级双向链表 扁平化多级双向链表 1 109_有序链表转换二叉搜索树 有序链表转换二叉搜索树 1 160_相交链表 相交链表 1 142_环形链表II 环形链表II 1 146_LRU缓存机制 LRU缓存机制 1 104_二叉树的最大深度 二叉树的最大深度 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/algorithm/index.html"}],"posts":[{"title":"109_有序链表转换二叉搜索树","text":"给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 Related Topics深度优先搜索链表 看答案的，自己想复杂了，对树这种结构掌握不太好。边界条件要注意。 时间复杂度O(n)，空间复杂度O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;Integer&gt; integerList; public Solution(){ this.integerList=new ArrayList&lt;&gt;(); } private void changeToList(ListNode node) { while (node != null) { this.integerList.add(node.val); node = node.next; } } public TreeNode sortedListToBST(ListNode head) { if (head == null) { return null; } changeToList(head); TreeNode treeNode = getBST(0, this.integerList.size() - 1); return treeNode; } private TreeNode getBST(int start, int end) { if (start &gt; end) { return null; } int mid = (start + end) &gt;&gt; 1; int midVal = integerList.get(mid); TreeNode treeNode = new TreeNode(midVal); if (start == end) { return treeNode; } TreeNode left = getBST(start, mid-1); TreeNode right = getBST(mid+1, end); treeNode.left = left; treeNode.right = right; return treeNode; } 91算法打卡第九天参考答案","link":"/2020/06/09/109_%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"146_LRU缓存机制","text":"给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明:&nbsp;叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度&nbsp;3 。 Related Topics树深度优先搜索 用递归就好,时间复杂度O(n)，每个节点都要遍历一次，空间复杂度O(1)，没有创建新的容器。。。 12345678class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right))+1; }} 91算法打卡第十二天参考答案","link":"/2020/06/13/104_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"1381_设计一个支持增量操作的栈","text":"请你设计一个支持下述操作的栈。 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。 void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。 int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。 void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 &nbsp; 示例： 输入： [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 输出： [null,null,null,2,null,null,null,null,null,103,202,201,-1] 解释： CustomStack customStack = new CustomStack(3); // 栈是空的 [] customStack.push(1); // 栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.pop(); // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.push(3); // 栈变为 [1, 2, 3] customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4 customStack.increment(5, 100); // 栈变为 [101, 102, 103] customStack.increment(2, 100); // 栈变为 [201, 202, 103] customStack.pop(); // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202] customStack.pop(); // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201] customStack.pop(); // 返回 201 --&gt; 返回栈顶值 201，栈变为 [] customStack.pop(); // 返回 -1 --&gt; 栈为空，返回 -1 &nbsp; 提示： 1 &lt;= maxSize &lt;= 1000 1 &lt;= x &lt;= 1000 1 &lt;= k &lt;= 1000 0 &lt;= val &lt;= 100 每种方法 increment，push 以及 pop 分别最多调用 1000 次 Related Topics栈设计 这道题感觉不是很难，一看到就有思路了。首先考虑数据结构，栈不行，不然在incr 这个方法会比较麻烦；链表不行，因为查找比较麻烦；所以就选择数组。push方法的时间复杂度为O(1), pop方法的时间复杂度为O(1)，incr 方法的时间复杂度为O(n)。空间复杂度，O(n)， 用了一个数组。 1234567891011121314151617181920212223242526272829303132333435class CustomStack { private Integer[] stack; private int index; private int maxSize; public CustomStack(int maxSize) { this.maxSize = maxSize; this.index = -1; this.stack = new Integer[maxSize]; } public void push(int x) { if (index &gt;= maxSize - 1) { return; } this.stack[++index] = x; } public int pop() { if (index == -1) { return -1; } int result = this.stack[index]; this.stack[index--] = null; return result; } public void increment(int k, int val) { int min = k &gt;= index + 1 ? index + 1 : k; for (int i = 0; i &lt; min; i++) { this.stack[i] += val; } } } 91算法打卡第三天参考答案","link":"/2020/06/03/1381_%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/"},{"title":"142_环形链表II","text":"给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 &nbsp; 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例&nbsp;2： 输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 &nbsp; 进阶： 你是否可以不用额外空间解决此题？ Related Topics链表双指针 第一种，暴力解法：时间复杂度 O(n)，空间复杂度O(n) 123456789101112131415public ListNode detectCycle(ListNode head) { if (head == null) { return null; } Set&lt;ListNode&gt; listNodes = new HashSet&lt;&gt;(); ListNode tempHead = head; while (tempHead != null) { if (listNodes.contains(tempHead)) { return tempHead; } listNodes.add(tempHead); tempHead = tempHead.next; } return null; } 第二种，快慢指针追及问题时间复杂度 O(n)，空间复杂度O(1) 12345678910111213141516171819202122232425public ListNode detectCycle(ListNode head) { if (head == null) { return null; } ListNode slowNode = head; ListNode fastNode = head; while (fastNode != null) { if (fastNode.next != null &amp;&amp; fastNode.next.next != null) { fastNode = fastNode.next.next; } else { return null; } slowNode = slowNode.next; if (slowNode == fastNode) { break; } } ListNode restartNode = head; while (restartNode != slowNode) { restartNode=restartNode.next; slowNode = slowNode.next; } return restartNode; } 91算法打卡第十一天参考答案","link":"/2020/06/11/142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"},{"title":"146_LRU缓存机制","text":"运用你所掌握的数据结构，设计和实现一个&nbsp; LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 &nbsp; 进阶: 你是否可以在&nbsp;O(1) 时间复杂度内完成这两种操作？ &nbsp; 示例: LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得关键字 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得关键字 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 Related Topics设计 时间复杂度O(1)，空间复杂度O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class LRUCache { int capatity; Node head; Node tail; Map&lt;Integer, Node&gt; map; public LRUCache(int capacity) { this.capatity = capacity; map = new HashMap&lt;&gt;(); head = null; tail = null; } public int get(int key) { if (map.containsKey(key)) { Node node = map.get(key); if (head != node) { removeNode(node); appendHead(node); } return node.val; } return -1; } public void put(int key, int value) { Node node = new Node(key, value); if (head == null &amp;&amp; tail == null) { head = tail = node; } else { Node existNode = map.get(key); if (existNode != null) { removeNode(existNode); }else if (map.size() == capatity) { int tailKey = tail.key; removeNode(tail); map.remove(tailKey); } appendHead(node); } map.put(key, node); } private void appendHead(Node node) { if (head == null) { head = tail = node; }else if (head != node) { Node tempHead = head; head = node; head.next = tempHead; tempHead.pre = head; } } private void removeNode(Node node) { if (head == tail) { head = tail = null; }else{ if (node == head) { head = head.next; node.next = null; head.pre = null; } else if (node == tail) { tail = tail.pre; node.pre = null; tail.next = null; }else{ Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; } } } public class Node { public int key; public int val; public Node next; public Node pre; public Node(int key, int val) { this.key = key; this.val = val; } }}/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 91算法打卡第十二天参考答案","link":"/2020/06/12/146_LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"160_相交链表","text":"编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 &nbsp; 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 &nbsp; 示例&nbsp;2： 输入：intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 &nbsp; 示例&nbsp;3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 &nbsp; 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 Related Topics链表 暴力解：时间复杂度O(n),空间复杂度O(n) 12345678910111213141516public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Map&lt;ListNode, Integer&gt; map = new HashMap(); ListNode tempA = headA; ListNode tempB = headB; while (tempA != null) { map.put(tempA, null); tempA = tempA.next; } while (tempB != null) { if (map.containsKey(tempB)) { return tempB; } tempB = tempB.next; } return null; } 第二种思路来自群友，很巧妙的解法。假设有A由a+b组成，B由c+b组成， b为交集部分那么 a+b+c=c+b+a 。以步长为1 同时遍历，最后两者相等即为交集点。时间复杂度O(n),空间复杂度O(1) 1234567891011121314public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode tempA = headA; ListNode tempB = headB; while (tempA != tempB) { tempA = tempA == null ? headB : tempA.next; tempB = tempB == null ? headA : tempB.next; } return tempA; } 91算法打卡第十天参考答案","link":"/2020/06/10/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"title":"206_反转链表","text":"反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ Related Topics链表 递归递归里面还有while，时间复杂度为O(n^2) 1234567891011121314151617 public ListNode reverseList(ListNode head) { if (head == null) { return null; } if (head!=null&amp;&amp;head.next == null) { return head; } ListNode node = reverseList(head.next); head.next = null; ListNode lastNode = node; while (lastNode.next != null) { lastNode = lastNode.next; } lastNode.next = head; return node; }` 迭代：可以参考讲义的内容将如下内容进行优化，时间复杂度O(n) 1234567891011121314public ListNode reverseList(ListNode head) { ListNode temp = null; if (head == null) { return null; } while (head.next != null) { ListNode tempHead = head; head = head.next; tempHead.next = temp; temp = tempHead; } head.next = temp; return head; } 91算法打卡第七天参考答案","link":"/2020/06/07/206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"232_用栈实现队列","text":"使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 -- 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 Related Topics栈设计 用了两个栈，一个是对外输出栈stack（里面的元素一直符合先入先出），一个是备用栈bakStack。当push操作时，先看下stack是否为空，stack不为空则把元素push到bakStack中。当pop操作时，先把stack里面的元素pop出来，然后再判断stack是否为空，如果stack为空，这时候把bakStack的元素全部补充进stack，注意，这步操作后，stack的元素为正序，即符合先入先出了。 空间复杂度 O(n)，时间复杂度 push 操作O(1)， pop 操作 O(n)，peek操作O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041class MyQueue { Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; bakStack; /** Initialize your data structure here. */ public MyQueue() { this.stack=new Stack(); this.bakStack = new Stack(); } /** Push element x to the back of queue. */ public void push(int x) { if(!stack.isEmpty()){ bakStack.push(x); }else{ stack.push(x); } } /** Removes the element from in front of queue and returns that element. */ public int pop() { int temp = stack.pop(); if(stack.isEmpty()){ while(!bakStack.isEmpty()){ stack.push(bakStack.pop()); } } return temp; } /** Get the front element. */ public int peek() { return stack.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack.isEmpty(); }} 91算法打卡第五天参考答案","link":"/2020/06/05/232_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"380_常数时间插入、删除和获取随机元素","text":"设计一个支持在平均&nbsp;时间复杂度 O(1)&nbsp;下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 : // 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.getRandom(); Related Topics设计数组哈希表 有想到数组加hashmap，但是一直没想到remove掉数组中的随机某个数后，怎么很好的填补这个空缺，以及纠结这个随机数不连贯了怎么办的问题。最后无奈看了小伙伴的解答，恍然大悟，拿最后一个数去填补，而不是我一开始设想的下次insert再去填补。。。get 123456789101112131415161718192021222324252627282930313233343536373839404142class RandomizedSet { Map&lt;Integer, Integer&gt; map; List&lt;Integer&gt; list; Random random = new Random(); /** Initialize your data structure here. */ public RandomizedSet() { map = new HashMap(); list = new ArrayList(); } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) { Integer result = map.get(val); if (result == null) { list.add(val); map.put(val, list.size() - 1); return true; } return false; } /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) { Integer listIndex = map.get(val); if (listIndex == null) { return false; } map.put(list.get(list.size() - 1), listIndex); map.remove(val); list.set(listIndex, list.get(list.size() - 1)); list.remove(list.size() - 1); return true; } /** Get a random element from the set. */ public int getRandom() { int randomIndex = random.nextInt(list.size()); return list.get(randomIndex); }} 91算法打卡第六天参考答案","link":"/2020/06/06/380_%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"},{"title":"394_字符串解码","text":"给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像&nbsp;3a&nbsp;或&nbsp;2[4]&nbsp;的输入。 &nbsp; 示例 1： 输入：s = &quot;3[a]2[bc]&quot; 输出：&quot;aaabcbc&quot; 示例 2： 输入：s = &quot;3[a2[c]]&quot; 输出：&quot;accaccacc&quot; 示例 3： 输入：s = &quot;2[abc]3[cd]ef&quot; 输出：&quot;abcabccdcdcdef&quot; 示例 4： 输入：s = &quot;abc3[cd]xyz&quot; 输出：&quot;abccdcdcdxyz&quot; Related Topics栈深度优先搜索 这道题写了超级久，原来用了两个栈，一个队列，然后没法一条路走到黑就放弃了。群里有个人评价博主的方法聪明，从栈里面拿出来计算好再放回去栈里面，一下子点醒我。然后问题迎刃而解。谢谢小伙伴~ 时间复杂度O(n)，空间复杂度O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.regex.Pattern;class Solution { public String decodeString(String s) { String sb = \"\"; Stack&lt;String&gt; strStack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { String word = \"\"; String repeatCount = \"\"; StringBuilder repeatWordSb = new StringBuilder(); if (chars[i] == ']') { while (!strStack.isEmpty() &amp;&amp; !strStack.peek().equals(\"[\")) { word = strStack.pop().toString() + word; } if (strStack.peek().equals(\"[\")) { strStack.pop(); } while (!strStack.isEmpty() &amp;&amp; isNumber(strStack.peek())) { repeatCount = strStack.pop().toString() + repeatCount; } for (int j = 0; j &lt; Integer.valueOf(repeatCount); j++) { repeatWordSb.append(word); } strStack.push(repeatWordSb.toString()); } else { strStack.push(String.valueOf(chars[i])); } } while (!strStack.isEmpty()) { sb = strStack.pop() + sb; } return sb; } public static boolean isNumber(String str){ Pattern compile = Pattern.compile(\"^[0-9]*$\"); return compile.matcher(str).matches(); }} 加油~ 91算法打卡第四天参考答案","link":"/2020/06/04/394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"title":"75_颜色分类","text":"给定一个包含红色、白色和蓝色，一共&nbsp;n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ Related Topics排序数组双指针 不知道这样符合群主要求不？过了leetcode的。不过觉得确实不好。这个方法是早上看了一个公众号借鉴的，不过看了其他同学的答案，又回过头看了公众号，自己应该是没有领悟到该方法的精髓。 该方法是假设有三个挡板，i , j ,k 。[0,i) 存1，[i,j) 存2，(k,nums.length -1] 存3 , [j,k] 为未排序区 //伪代码如下 while (j&lt;=k){ //穷尽各种可能性，毕竟只有三种数字。}时间复杂度 O(n)，空间复杂度O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public void sortColors(int[] nums) { int i = 0 ; int j = 0 ; int k = nums.length -1 ; while (j&lt;=k){ if(nums[i]==0){ if(i==j){ j++; } i++; continue; } if(nums[j]==1){ j++; continue; } if(nums[k]==2){ k--; continue; } if(nums[i]==1&amp;&amp;nums[j]==0){ nums[i]=0; nums[j]=1; i++; j++; continue; } if(nums[i]==2&amp;&amp;nums[k]==0){ nums[i]=0; nums[k]=2; if(i==j){ j++; } i++; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==0){ nums[j]=0; nums[k]=2; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==1){ nums[j]=1; nums[k]=2; j++; k--; continue; } } }} 改进： 时间复杂度 O(n)，空间复杂度O(1) 1234567891011121314151617181920212223242526272829class Solution { private void swap(int[] nums,int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } public void sortColors(int[] nums) { int i = 0 ; int cur = 0; int k = nums.length -1 ; while ( i &lt;= k &amp;&amp; cur &lt;= k ){ if(nums[cur]==0){ swap(nums,cur,i); i++; cur++; }else if(nums[cur]==1){ cur++; }else if(nums[cur]==2){ swap(nums,cur,k); k--; //cur++; 无法确定换回来的数是什么，所以不能加这个。 } } }} 91算法打卡第二天参考答案","link":"/2020/06/02/75_%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"},{"title":"66_加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 123456789101112131415161718192021class Solution { public int[] plusOne(int[] digits) { for(int i = digits.length-1;i&gt;=0;i--){ if(digits[i]+1==10){ digits[i]=0; }else{ digits[i]+=1; break; } } //the old digits is 9 or 99 and so on if(digits[0]==0){ int[] newDigits=new int[digits.length+1]; newDigits[0]=1; return newDigits; } return digits; }} 以前有做过，当回顾~ 第一天打卡(^__^) 91算法打卡第一天参考答案","link":"/2020/06/01/66_%E5%8A%A0%E4%B8%80/"},{"title":"430_扁平化多级双向链表","text":"多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 &nbsp; 示例 1： 输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 输出：[1,2,3,7,8,11,12,9,10,4,5,6] 解释： 输入的多级列表如下图所示： 扁平化后的链表如下图： 示例 2： 输入：head = [1,2,null,3] 输出：[1,3,2] 解释： 输入的多级列表如下图所示： 1---2---NULL | 3---NULL 示例 3： 输入：head = [] 输出：[] &nbsp; 如何表示测试用例中的多级链表？ 以 示例 1 为例： 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后： [1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。 [1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。 [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] &nbsp; 提示： 节点数目不超过 1000 1 &lt;= Node.val &lt;= 10^5 Related Topics深度优先搜索链表 这道题想了很久哎，最后看了答案，觉得用先序遍历最好理解。主要是多增加一个全局Node，然后先序遍历创建一个新的链表，最后把一开始的全局Node删除即可。 时间复杂度为O(n),空间复杂度O(1) 1234567891011121314151617181920212223242526272829class Solution { Node globalHead = new Node(); Node prev = globalHead; public Node flatten(Node head) { if (head == null) { return null; } preOrderTravel(head); head = globalHead.next; head.prev = null; globalHead.next = null; return head; } private void preOrderTravel(Node head) { if (head == null) { return; } Node child = head.child; Node next = head.next; head.next = head.child = null; prev.next = head; head.prev = prev; prev = head; preOrderTravel(child); preOrderTravel(next); }} 91算法打卡第八天参考答案","link":"/2020/06/08/430_%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"单一职责原则","text":"基本介绍： 对类来说，即一个类只负责一项职责。如类A 负责两个不同职责： 职责1，职责2。当职责1 需求变更而改变A时，可能会造成职责2执行错误，所以需要将类A的粒度分解成A1，A2 反例：12345678910111213141516171819202122232425262728public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路上面跑\"); }}public class SingleResponsibility1 { //方式1 的run方法违反单一职责原则 //解决的方案非常简单，根据交通工具运行方式不同，分解不同类即可。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.run(\"飞机\"); //wrong }} 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class RoadVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在公路运行\"); }}public class AirVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在空中运行\"); }}public class WaterVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility2 { //方式2 遵守了单一职责，但是这样的改动很大，即将类分解，同时修改客户端。 public static void main(String[] args) { RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run(\"摩托车\"); roadVehicle.run(\"汽车\"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run(\"飞机\"); WaterVehicle waterVehicle = new WaterVehicle(); waterVehicle.run(\"潜水艇\"); }} 改进：12345678910111213141516171819202122232425262728293031323334353637383940public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路运行\"); } public void runAir (String vehicle){ System.out.println(vehicle+\"在天空运行\"); } public void runWater (String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility3 { //方式3 只是增加了方法。虽然没有类这个级别上遵守单一职责原则，但是在方法的级别上，仍然准备单一职责原则的。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.runAir(\"飞机\"); }} 注意细节事项和细节： 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则的；只有类中方法数量足够少，才可以在方法级别保持单一职责原则。 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/15/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"},{"title":"Tomcat8.5.50源码环境搭建","text":"学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 1. 首先到tomcat官网下载 src 和 部署包。 2. 下载后解压src 包和 bin包。3. 在src包中添加pom.xml文件，引入需要的依赖。 在pom.xml添加如下配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5&lt;/name&gt; &lt;version&gt;8.5&lt;/version&gt; &lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--Tomcat是java开发的，封装了很多新功能，它需要依赖一些基础的jar包--&gt; &lt;dependencies&gt; &lt;!--远程过程调用工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--soap协议处理工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt; &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--解析webservice的wsdl文件工具--&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eclipse Java编译器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--ant管理工具--&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--easymock辅助单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 启动idea，导入该项目，并将它转成maven工程。 5. tomcat是一个java se工程，在config中配置启动类： 其中，vm option的具体配置如下： 1234-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties 6. 保存好。如果现在启动会因为jsp没有解析报错，所以需要添加jsp 的解析，如下：在ContextConfig的类中configureStart 方法添加 初始化jsp解析引擎： 1234//位置：package org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:788) //初始化jsp解析引擎-japser context.addServletContainerInitializer(new JasperInitializer(), null); 7. 启动tomcat ,可以访问到tomcat的页面了。控制台乱码解决杰哥总结了3种方法，读者按需配置： 设置语言环境： 在如上的第6步的vm option 添加如下配置，将环境改成英文环境，避免乱码: 1234567-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties-Dfile.encoding=UTF-8-Duser.language=en-Duser.region=US 修改如下两个地方的编码： pom 的jdk 修改成11，并做好jdk11 的环境安装配置(未尝试) 1234567891011121314151617181920212223&lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","link":"/2020/05/13/Tomcat8.5.50%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"依赖倒转原则","text":"基本介绍 依赖倒转原则(Dependence Inversion Principle)是指： 细节应该依赖抽象 依赖倒转(倒置)的本质是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 反例：123456789101112131415161718192021public class Sms { public String getMsg(){ return \"hello world\"; }}public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 如上Mobile类的receiveMsg方法参数是具体的对象Sms，如果以后还需要接收其他类型的数据，比如微信等，需要重新写方法，非常不利于扩展，改动大。 正例：改成面向接口对象即可。 123456789101112131415161718192021222324252627282930313233343536public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用案例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 构造方法传递 1234567891011121314151617181920212223242526272829303132333435363738public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; public DuckFly(Run run) { this.run = run; } @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(quickRun); duckFly.flyHigh(); }} setter 方法传递(较少使用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); } public Run getRun() { return run; } public void setRun(Run run) { this.run = run; }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); DuckFly duckFly = new DuckFly(); duckFly.setRun(quickRun); duckFly.flyHigh(); }} 依赖倒转原则的注意事项和细节 低层模块最好有接口或者实现类，这样程序稳定性好 变量的声明尽量是抽象类或者方法，这样变量引用和实际对象间有了一个缓冲，利于程序的扩展和优化 比如我们方法参数常用List 而不是ArrayList，这样当我们需要LinkedList的时候，方法不需要改变什么就可以直接使用了。 继承时要遵循里氏替换原则（下节内容） 解释：每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/20/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/"},{"title":"合成复用原则","text":"基本介绍原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对实现编程 尽可能实现松耦合设计 合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 下面以摩托车分类管理程序为例来介绍合成复用原则的应用。 分析：摩托车按“动力源”划分可分为汽油摩托车、电动摩托车等；按“颜色”划分可分为白色摩托车、黑色摩托车和红色摩托车等。如果同时考虑这两种分类，其组合就很多。如下所示是用继承关系实现的摩托车分类的类图。 我们可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下 所示。 总结结合前几节的内容，我们一共介绍了 7种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则。 这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。","link":"/2020/06/07/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/"},{"title":"开闭原则","text":"基本介绍 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。 就比如开发新需求，你大可以扩展代码，但是你要确保原先的调用者不用发生一丁点变化。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中使用设计模式的目的就是为了遵循开闭原则。 反例： 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class Shape { int shapeType;}public class Rectangle extends Shape{ public Rectangle() { super.shapeType=1; }}public class Circle extends Shape{ public Circle() { super.shapeType=2; }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ if (s.shapeType==1) { drawRectangle(s); }else if (s.shapeType==2){ drawCircle(s); } } private void drawCircle(Shape s) { System.out.println(\"绘制圆形\"); } private void drawRectangle(Shape s) { System.out.println(\"绘制矩形\"); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如上设计，当我们要绘制一个新的图形，比如三角形，我们一定要动到GraphicEditor这个使用方的类，这样就违反了开闭原则了。 12345678910111213141516171819202122public class Triangle extends Shape{ public Triangle() { super.shapeType=3; }}public class GraphicEditor { public void drawShape(Shape s){ //省略重复代码... else if (s.shapeType==2){ drawTriangle(s); } } private void drawTriangle(Shape s) { System.out.println(\"绘制三角形\"); }} 正例：思路： 我们在shape类中提供一个抽象方法，让子类去实现即可。这样当我们有新的图形类继承的时候，实现draw方法即可，也避免修改使用方的代码，从而满足开闭原则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Shape { int shapeType; abstract void drawShape();}public class Rectangle extends Shape { public Rectangle() { super.shapeType=1; } @Override void drawShape() { System.out.println(\"绘制矩形\"); }}public class Circle extends Shape { public Circle() { super.shapeType=2; } @Override void drawShape() { System.out.println(\"绘制圆形\"); }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ s.drawShape(); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如 依赖倒转原则的正例，也是符合开闭原则的范例，可以回顾下~ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/23/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"},{"title":"数组_53最大子序和","text":"给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 Related Topics数组分治算法动态规划 这道题花了两个小时。各种考虑不周。其实三天前就看了答案的，知道有负收益这回事，但是真到了码代码就出错了。 1234567891011121314151617181920212223242526class Solution { public int maxSubArray(int[] nums) { //记录目前出现的最大的和 int max = nums[0]; //连续求和 int sum = 0; //一开始就赋值nums[0]，并循环从下标为1 的开始，导致漏了这种情况 [-1,2,3],无经验的表现。 for (int i = 0; i &lt; nums.length; i++) { sum+=nums[i]; //一旦sum小于等于0，就是无收益，放弃这个子数组，准备重新取值 if (sum &lt;= 0) { if(nums[i]&gt;0){ //nums[i]还是正收益，取该值 sum=nums[i]; }else { //nums[i]&lt;=0,从下个开始取 sum=0; } max = Math.max(nums[i], max); }else { max = Math.max(sum, max); } } return max; }} 看题解，思路更易懂些： 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for(int num: nums) { if(sum &gt; 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }}","link":"/2020/05/20/%E6%95%B0%E7%BB%84_53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"接口隔离原则","text":"基本介绍 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 改造前：改造前，如下UML图所示 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public interface Interface1 {​ void operation1();​ void operation2();​ void operation3();​ void operation4();​ void operation5();}public class B implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"B 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"B 实现了operation5\");​ }}public class D implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"D 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"D 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend2(Interface1 inteface1){​ inteface1.operation2();​ }​ public void depend3(Interface1 inteface1){​ inteface1.operation3();​ }}public class C {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend4(Interface1 inteface1){​ inteface1.operation4();​ }​ public void depend5(Interface1 inteface1){​ inteface1.operation5();​ }} 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D。如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。 按照接口隔离原则应当如下处理： 将接口Interface1拆分成几个接口（这里我们拆分成3个接口），类Ａ和类Ｃ分别与他们需要的接口建立依赖关系。 改造后：改进的UML类图如下： 改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public interface Interface1 {​ void operation1();}public interface Interface2 {​ void operation2();​ void operation3();}public interface Interface3 {​ void operation4();​ void operation5();}public class B implements Interface1,Interface2 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }}public class D implements Interface1,Interface3 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend2(Interface2 inteface){​ inteface.operation2();​ }​ public void depend3(Interface2 inteface){​ inteface.operation3();​ }}public class C {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend4(Interface3 inteface){​ inteface.operation4();​ }​ public void depend5(Interface3 inteface){​ inteface.operation5();​ }} 测试代码如下： 12345678910111213141516171819202122public static void main(String[] args) {​ A a = new A();​ a.depend1(new B()); //A 类通过接口去依赖(使用)B​ a.depend2(new B());​ a.depend3(new B());​ C c = new C();​ c.depend1(new D());//C 类通过接口去依赖(使用)D​ c.depend4(new D());​ c.depend5(new D());​ } 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/17/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"},{"title":"数组_66加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 1234567891011121314public int[] plusOne(int[] digits) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; digits.length; i++) { sb.append(digits[i]); } String s = sb.toString(); BigDecimal value = new BigDecimal(s); char[] chars = String.valueOf(value.add(new BigDecimal(1))).toCharArray(); int[] sum = new int[chars.length]; for (int i = 0; i &lt; chars.length; i++) { sum[i] = ( chars[i]-'0'); } return sum;} 这是我原来三天前的思路。想转成整数然后相加，把计算交给程序，奈何随着输入的数组长度越来越长，总是会溢出，然后我看了思路，觉得自己太傻，就为了自己省事，唉，在做算法题啊。 以下是我看完思路后，三天后独立完成的。 1234567891011121314151617public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i &gt;= 0; i--) { if (digits[i]+1&lt;10){ digits[i]=digits[i]+1; break; }else { digits[i]=0; } } if (digits[0] == 0) { int[] ints = new int[digits.length + 1]; ints[0]=1; return ints; } return digits; }","link":"/2020/05/21/%E6%95%B0%E7%BB%84_66%E5%8A%A0%E4%B8%80/"},{"title":"算法前言","text":"根据up主小齐的经验，她的第一阶段是根据MIT的算法导论课的课程顺序调整Leetcode的刷题顺序的，如下就是该课程的排课表： 截止到目前[20200519]，杰哥已经刷了13道题了（easy难度，题号从小到大的排序），还是比较弱鸡的。杰哥也会根据这个排课表重新调整刷题顺序的，需要继续努力啊，少年。 第一阶段刷题： 数组： Leetcode no.53 最大子序和 Leetcode no.66 加1 2020年06月01日加入了 91算法群,和小伙伴一起刷算法题。以下是每天刷题记录: 数组、栈、队列： 2020-06-01 - 66. 加一 2020-06-02 - 75. 颜色分类 2020-06-03 - 1381. 设计一个支持增量操作的栈 2020-06-04 - 394. 字符串解码 2020-06-05 - 232. 用栈实现队列 2020-06-06 - 380. 常数时间插入、删除和获取随机元素 链表： 2020-06-07 - 206. 反转链表 2020-06-08 - 430. 扁平化多级双向链表 2020-06-09 - 109. 有序链表转换二叉搜索树 2020-06-10 - 160. 相交链表 2020-06-11 - 142. 环形链表 II 2020-06-12 - 146. LRU缓存机制 2020-06-13 - 104. 二叉树的最大深度","link":"/2020/05/19/%E7%AE%97%E6%B3%95%E5%89%8D%E8%A8%80/"},{"title":"设计模式前言","text":"设计模式：软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由Erich Gamma 等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式的目的： 代码重用性 可读性 可扩展性 可靠性 使程序呈现高内聚，低耦合的提醒 设计模式包含了对象的精髓，” 懂了设计模式，你就懂了面向对象分析和设计的精要 “ 设计模式七个原则： 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则 ocp 迪米特法则 合成复用原则 UML科普文","link":"/2020/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E8%A8%80/"},{"title":"数组_88合并两个有序数组","text":"给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。 &nbsp; 说明: 初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。 你可以假设&nbsp;nums1&nbsp;有足够的空间（空间大小大于或等于&nbsp;m + n）来保存 nums2 中的元素。 &nbsp; 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出:&nbsp;[1,2,2,3,5,6] Related Topics数组双指针 这道题还是蛮简单的，只要注意参数m 和 n 就好。 12345678910111213141516171819202122232425262728293031323334class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int p=m+n; while(m&gt;0||n&gt;0){ p--; //exist m and n ,compare if(m&gt;0&amp;&amp;n&gt;0){ if(nums1[m-1]&gt;nums2[n-1]){ nums1[p] = nums1[m - 1]; m--; }else{ nums1[p] = nums2[n - 1]; n--; } continue; } //only exits m,move m if(m&gt;0){ nums1[p] = nums1[m - 1]; m--; continue; } //only exits n,move n if(n&gt;0){ nums1[p] = nums2[n - 1]; n--; continue; } } }}","link":"/2020/05/23/%E6%95%B0%E7%BB%84_88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"迪米特法则","text":"基本介绍 一个对象应该对其他对象保存最少的了解 类与类关系越密切，耦合度越大 迪米特法则(Demeter Principle) 又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。 迪米特法则还有一个更加简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的关系很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也是就是说，陌生的类最好不要以局部变量的形式出现在类的内部中。 代码例子： 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id 反例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//学院的员工类public class CollegeEmployee { private String id; public String getId() { return id; } public void setId(String id) { this.id = id; }}//学校的员工类public class Employee { private String id; public String getId() { return id; } public void setId(String id) { this.id = id; }}//学院管理类public class CollegeManager { public List&lt;CollegeEmployee&gt; getAllEmployee(){ List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(\"学院员工id=\" + i); list.add(collegeEmployee); } return list; }}//学校管理类public class SchoolManager { public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Employee employee = new Employee(); employee.setId(\"学校总部iD=\"+i); employees.add(employee); } return employees; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(CollegeManager sub){ //1.这里的CollegeEmployee 不是SchoolManager的直接朋友 //1.CollegeEmployee 是以局部变量的方式出现在SchoolManager中，不符合迪米特法则 //获取学院的员工 List&lt;CollegeEmployee&gt; allEmployee = sub.getAllEmployee(); for (CollegeEmployee e:allEmployee ) { System.out.println(e.getId()); } //获取学校的员工 List&lt;Employee&gt; allEmployee1 = this.getAllEmployee(); for (Employee e : allEmployee1) { System.out.println(e.getId()); } }}//打印public class Demeter1 { public static void main(String[] args) { SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmp(new CollegeManager()); }} 代码64行，CollegeEmployee 不是SchoolManager的直接朋友，它是以局部变量的方式出现在SchoolManager中，不符合迪米特法则。 改进：思路：我们只需要将打印学院员工编号的逻辑移到CollegeManager ，然后 SchoolManager 再调用CollegeManager的打印方法即可。这样就符合迪米特法则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//学院管理类public class CollegeManager { public List&lt;CollegeEmployee&gt; getAllEmployee(){ List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(\"学院员工id=\" + i); list.add(collegeEmployee); } return list; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(){ List&lt;CollegeEmployee&gt; allEmployee = getAllEmployee(); for (CollegeEmployee e:allEmployee ) { System.out.println(e.getId()); } }}//学校管理类public class SchoolManager { public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Employee employee = new Employee(); employee.setId(\"学校总部iD=\"+i); employees.add(employee); } return employees; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(CollegeManager sub){ sub.printAllEmp(); //获取学校的员工 List&lt;Employee&gt; allEmployee1 = this.getAllEmployee(); for (Employee e : allEmployee1) { System.out.println(e.getId()); } }} 迪米特法则注意事项和细节： 迪米特法则的核心是降低类之间的耦合 但是注意：迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完成没有依赖关系 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/06/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"},{"title":"里氏替换原则","text":"OO中的继承性的思考和说明 继承包含这样一层含义： 父类中凡是已经实现好的方法，实际上是在设计规范，虽然它不强制要求所有子类必须遵循这些规范，但是如果子类如果对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。 继承给程序设计带来便利的同时，也带来了弊端。比如使用了继承，父类的任何改动都得考虑到所有继承的子类，并且父类修改后，所有涉及到的子类功能都有可能产生故障。 问题提出：如何正确使用继承？ 里氏替换原则 基本介绍 里氏替换原则（Liskov Substitution Principle）在1988年，由麻省理工学院的一位姓里的女士提出的。 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方都必须能透明地使用其子类对象。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 反例：12345678910111213141516171819202122232425262728293031323334public class A { //a + b public Integer function1(int a,int b){ return a + b; }}public class B extends A{ //change function1 of A by accident @Override public Integer function1(int a, int b) { return a-b; }}public class Main { public static void main(String[] args) { A a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); A b = new B(); System.out.println(\"1+2=\"+b.function1(1, 2)); //没想到B 已经改了继承的方法，造成结果错误 System.out.println(\"2+3=\"+b.function1(2, 3)); }} 测试结果： 解决方法： B类不小心改了A类的方法，导致调用出错。在实际开发中，我们常常会通过修改父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系复用性比较差。 通用的做法是：将原来的父类和子类都继承一个更加通用的基类，原有的继承关系去掉，采用依赖，聚合，组合等方式代替。 改进后的方案如下： 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Base { public abstract Integer function1(int a, int b);}public class A extends Base{ //a + b @Override public Integer function1(int a,int b){ return a + b; }}public class B extends Base { A a = new A(); //a-b @Override public Integer function1(int a, int b) { return a-b; } public Integer function2(int i, int j){ return a.function1(i, j); }}public class Main { public static void main(String[] args) { Base a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); Base b = new B(); System.out.println(\"1-2=\"+b.function1(1, 2)); System.out.println(\"2-3=\"+b.function1(2, 3)); }} 总之，里氏替换原则告诉我们，子类中尽量不要重写父类的方法！ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/23/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"刷算法题","slug":"刷算法题","link":"/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/tags/tomcat%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"刷算法题","slug":"刷算法题","link":"/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/categories/tomcat%E6%BA%90%E7%A0%81/"}]}