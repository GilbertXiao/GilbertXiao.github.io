{"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"源码 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 Tomcat8.5.50源码环境搭建 学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/code-source/index.html"},{"title":"","text":"漫画算法 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 漫画算法(顺序已经整理好) 1 漫画算法 漫画算法 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/readings/ComicAlgorithm.html"},{"title":"","text":"刷算法题 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 算法前言 刷题前述 1 数组_53最大子序和 给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和 1 数组_66加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 1 数组_88合并两个有序数组 给你两个有序整数数组nums1和 nums2，请你将 nums2 合并到nums1中，使 nums1成为一个有序数组。 1 66_加一 为什么又是加一？因为这是加入算法组织的第一天出的题~ 1 75_颜色分类 给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 1 1381_设计一个支持增量操作的栈 实现自定义栈类 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/algorithm/index.html"},{"title":"","text":"设计模式 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 设计模式(顺序已经整理好) 1 设计模式前言 软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 1 单一职责原则 对类来说，即一个类只负责一项职责。 1 接口隔离原则 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 1 依赖倒转原则 细节应该依赖抽象; 依赖倒转(倒置)的本质是面向接口编程 1 里氏替换原则 细节应该依赖抽象; 依赖倒转(倒置)的本质是面向接口编程 1 开闭原则 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/designPattern/index.html"}],"posts":[{"title":"66_加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 123456789101112131415161718192021class Solution { public int[] plusOne(int[] digits) { for(int i = digits.length-1;i&gt;=0;i--){ if(digits[i]+1==10){ digits[i]=0; }else{ digits[i]+=1; break; } } //the old digits is 9 or 99 and so on if(digits[0]==0){ int[] newDigits=new int[digits.length+1]; newDigits[0]=1; return newDigits; } return digits; }} 以前有做过，当回顾~ 第一天打卡(^__^) 91算法打卡第一天参考答案","link":"/2020/06/01/66_%E5%8A%A0%E4%B8%80/"},{"title":"1381_设计一个支持增量操作的栈","text":"请你设计一个支持下述操作的栈。 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。 void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。 int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。 void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 &nbsp; 示例： 输入： [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 输出： [null,null,null,2,null,null,null,null,null,103,202,201,-1] 解释： CustomStack customStack = new CustomStack(3); // 栈是空的 [] customStack.push(1); // 栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.pop(); // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.push(3); // 栈变为 [1, 2, 3] customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4 customStack.increment(5, 100); // 栈变为 [101, 102, 103] customStack.increment(2, 100); // 栈变为 [201, 202, 103] customStack.pop(); // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202] customStack.pop(); // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201] customStack.pop(); // 返回 201 --&gt; 返回栈顶值 201，栈变为 [] customStack.pop(); // 返回 -1 --&gt; 栈为空，返回 -1 &nbsp; 提示： 1 &lt;= maxSize &lt;= 1000 1 &lt;= x &lt;= 1000 1 &lt;= k &lt;= 1000 0 &lt;= val &lt;= 100 每种方法 increment，push 以及 pop 分别最多调用 1000 次 Related Topics栈设计 这道题感觉不是很难，一看到就有思路了。首先考虑数据结构，栈不行，不然在incr 这个方法会比较麻烦；链表不行，因为查找比较麻烦；所以就选择数组。push方法的时间复杂度为O(1), pop方法的时间复杂度为O(1)，incr 方法的时间复杂度为O(n)。空间复杂度，O(n)， 用了一个数组。 1234567891011121314151617181920212223242526272829303132333435class CustomStack { private Integer[] stack; private int index; private int maxSize; public CustomStack(int maxSize) { this.maxSize = maxSize; this.index = -1; this.stack = new Integer[maxSize]; } public void push(int x) { if (index &gt;= maxSize - 1) { return; } this.stack[++index] = x; } public int pop() { if (index == -1) { return -1; } int result = this.stack[index]; this.stack[index--] = null; return result; } public void increment(int k, int val) { int min = k &gt;= index + 1 ? index + 1 : k; for (int i = 0; i &lt; min; i++) { this.stack[i] += val; } } } 91算法打卡第三天参考答案","link":"/2020/06/03/1381_%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/"},{"title":"依赖倒转原则","text":"基本介绍 依赖倒转原则(Dependence Inversion Principle)是指： 细节应该依赖抽象 依赖倒转(倒置)的本质是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 反例：123456789101112131415161718192021public class Sms { public String getMsg(){ return \"hello world\"; }}public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 如上Mobile类的receiveMsg方法参数是具体的对象Sms，如果以后还需要接收其他类型的数据，比如微信等，需要重新写方法，非常不利于扩展，改动大。 正例：改成面向接口对象即可。 123456789101112131415161718192021222324252627282930313233343536public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用案例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 构造方法传递 1234567891011121314151617181920212223242526272829303132333435363738public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; public DuckFly(Run run) { this.run = run; } @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(quickRun); duckFly.flyHigh(); }} setter 方法传递(较少使用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); } public Run getRun() { return run; } public void setRun(Run run) { this.run = run; }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); DuckFly duckFly = new DuckFly(); duckFly.setRun(quickRun); duckFly.flyHigh(); }} 依赖倒转原则的注意事项和细节 低层模块最好有接口或者实现类，这样程序稳定性好 变量的声明尽量是抽象类或者方法，这样变量引用和实际对象间有了一个缓冲，利于程序的扩展和优化 比如我们方法参数常用List 而不是ArrayList，这样当我们需要LinkedList的时候，方法不需要改变什么就可以直接使用了。 继承时要遵循里氏替换原则（下节内容） 解释：每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/20/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/"},{"title":"75_颜色分类","text":"给定一个包含红色、白色和蓝色，一共&nbsp;n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ Related Topics排序数组双指针 不知道这样符合群主要求不？过了leetcode的。不过觉得确实不好。这个方法是早上看了一个公众号借鉴的，不过看了其他同学的答案，又回过头看了公众号，自己应该是没有领悟到该方法的精髓。 该方法是假设有三个挡板，i , j ,k 。[0,i) 存1，[i,j) 存2，(k,nums.length -1] 存3 , [j,k] 为未排序区 //伪代码如下 while (j&lt;=k){ //穷尽各种可能性，毕竟只有三种数字。}时间复杂度 O(n)，空间复杂度O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public void sortColors(int[] nums) { int i = 0 ; int j = 0 ; int k = nums.length -1 ; while (j&lt;=k){ if(nums[i]==0){ if(i==j){ j++; } i++; continue; } if(nums[j]==1){ j++; continue; } if(nums[k]==2){ k--; continue; } if(nums[i]==1&amp;&amp;nums[j]==0){ nums[i]=0; nums[j]=1; i++; j++; continue; } if(nums[i]==2&amp;&amp;nums[k]==0){ nums[i]=0; nums[k]=2; if(i==j){ j++; } i++; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==0){ nums[j]=0; nums[k]=2; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==1){ nums[j]=1; nums[k]=2; j++; k--; continue; } } }} 改进： 时间复杂度 O(n)，空间复杂度O(1) 1234567891011121314151617181920212223242526272829class Solution { private void swap(int[] nums,int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } public void sortColors(int[] nums) { int i = 0 ; int cur = 0; int k = nums.length -1 ; while ( i &lt;= k &amp;&amp; cur &lt;= k ){ if(nums[cur]==0){ swap(nums,cur,i); i++; cur++; }else if(nums[cur]==1){ cur++; }else if(nums[cur]==2){ swap(nums,cur,k); k--; //cur++; 无法确定换回来的数是什么，所以不能加这个。 } } }} 91算法打卡第二天参考答案","link":"/2020/06/02/75_%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"},{"title":"Tomcat8.5.50源码环境搭建","text":"学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 1. 首先到tomcat官网下载 src 和 部署包。 2. 下载后解压src 包和 bin包。3. 在src包中添加pom.xml文件，引入需要的依赖。 在pom.xml添加如下配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5&lt;/name&gt; &lt;version&gt;8.5&lt;/version&gt; &lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--Tomcat是java开发的，封装了很多新功能，它需要依赖一些基础的jar包--&gt; &lt;dependencies&gt; &lt;!--远程过程调用工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--soap协议处理工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt; &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--解析webservice的wsdl文件工具--&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eclipse Java编译器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--ant管理工具--&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--easymock辅助单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 启动idea，导入该项目，并将它转成maven工程。 5. tomcat是一个java se工程，在config中配置启动类： 其中，vm option的具体配置如下： 1234-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties 6. 保存好。如果现在启动会因为jsp没有解析报错，所以需要添加jsp 的解析，如下：在ContextConfig的类中configureStart 方法添加 初始化jsp解析引擎： 1234//位置：package org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:788) //初始化jsp解析引擎-japser context.addServletContainerInitializer(new JasperInitializer(), null); 7. 启动tomcat ,可以访问到tomcat的页面了。控制台乱码解决杰哥总结了3种方法，读者按需配置： 设置语言环境： 在如上的第6步的vm option 添加如下配置，将环境改成英文环境，避免乱码: 1234567-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties-Dfile.encoding=UTF-8-Duser.language=en-Duser.region=US 修改如下两个地方的编码： pom 的jdk 修改成11，并做好jdk11 的环境安装配置(未尝试) 1234567891011121314151617181920212223&lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","link":"/2020/05/13/Tomcat8.5.50%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"单一职责原则","text":"基本介绍： 对类来说，即一个类只负责一项职责。如类A 负责两个不同职责： 职责1，职责2。当职责1 需求变更而改变A时，可能会造成职责2执行错误，所以需要将类A的粒度分解成A1，A2 反例：12345678910111213141516171819202122232425262728public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路上面跑\"); }}public class SingleResponsibility1 { //方式1 的run方法违反单一职责原则 //解决的方案非常简单，根据交通工具运行方式不同，分解不同类即可。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.run(\"飞机\"); //wrong }} 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class RoadVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在公路运行\"); }}public class AirVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在空中运行\"); }}public class WaterVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility2 { //方式2 遵守了单一职责，但是这样的改动很大，即将类分解，同时修改客户端。 public static void main(String[] args) { RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run(\"摩托车\"); roadVehicle.run(\"汽车\"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run(\"飞机\"); WaterVehicle waterVehicle = new WaterVehicle(); waterVehicle.run(\"潜水艇\"); }} 改进：12345678910111213141516171819202122232425262728293031323334353637383940public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路运行\"); } public void runAir (String vehicle){ System.out.println(vehicle+\"在天空运行\"); } public void runWater (String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility3 { //方式3 只是增加了方法。虽然没有类这个级别上遵守单一职责原则，但是在方法的级别上，仍然准备单一职责原则的。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.runAir(\"飞机\"); }} 注意细节事项和细节： 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则的；只有类中方法数量足够少，才可以在方法级别保持单一职责原则。 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/15/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"},{"title":"开闭原则","text":"基本介绍 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。 就比如开发新需求，你大可以扩展代码，但是你要确保原先的调用者不用发生一丁点变化。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中使用设计模式的目的就是为了遵循开闭原则。 反例： 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class Shape { int shapeType;}public class Rectangle extends Shape{ public Rectangle() { super.shapeType=1; }}public class Circle extends Shape{ public Circle() { super.shapeType=2; }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ if (s.shapeType==1) { drawRectangle(s); }else if (s.shapeType==2){ drawCircle(s); } } private void drawCircle(Shape s) { System.out.println(\"绘制圆形\"); } private void drawRectangle(Shape s) { System.out.println(\"绘制矩形\"); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如上设计，当我们要绘制一个新的图形，比如三角形，我们一定要动到GraphicEditor这个使用方的类，这样就违反了开闭原则了。 12345678910111213141516171819202122public class Triangle extends Shape{ public Triangle() { super.shapeType=3; }}public class GraphicEditor { public void drawShape(Shape s){ //省略重复代码... else if (s.shapeType==2){ drawTriangle(s); } } private void drawTriangle(Shape s) { System.out.println(\"绘制三角形\"); }} 正例：思路： 我们在shape类中提供一个抽象方法，让子类去实现即可。这样当我们有新的图形类继承的时候，实现draw方法即可，也避免修改使用方的代码，从而满足开闭原则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Shape { int shapeType; abstract void drawShape();}public class Rectangle extends Shape { public Rectangle() { super.shapeType=1; } @Override void drawShape() { System.out.println(\"绘制矩形\"); }}public class Circle extends Shape { public Circle() { super.shapeType=2; } @Override void drawShape() { System.out.println(\"绘制圆形\"); }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ s.drawShape(); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如 依赖倒转原则的正例，也是符合开闭原则的范例，可以回顾下~ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/23/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"},{"title":"数组_53最大子序和","text":"给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 Related Topics数组分治算法动态规划 这道题花了两个小时。各种考虑不周。其实三天前就看了答案的，知道有负收益这回事，但是真到了码代码就出错了。 1234567891011121314151617181920212223242526class Solution { public int maxSubArray(int[] nums) { //记录目前出现的最大的和 int max = nums[0]; //连续求和 int sum = 0; //一开始就赋值nums[0]，并循环从下标为1 的开始，导致漏了这种情况 [-1,2,3],无经验的表现。 for (int i = 0; i &lt; nums.length; i++) { sum+=nums[i]; //一旦sum小于等于0，就是无收益，放弃这个子数组，准备重新取值 if (sum &lt;= 0) { if(nums[i]&gt;0){ //nums[i]还是正收益，取该值 sum=nums[i]; }else { //nums[i]&lt;=0,从下个开始取 sum=0; } max = Math.max(nums[i], max); }else { max = Math.max(sum, max); } } return max; }} 看题解，思路更易懂些： 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for(int num: nums) { if(sum &gt; 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }}","link":"/2020/05/20/%E6%95%B0%E7%BB%84_53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"接口隔离原则","text":"基本介绍 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 改造前：改造前，如下UML图所示 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public interface Interface1 {​ void operation1();​ void operation2();​ void operation3();​ void operation4();​ void operation5();}public class B implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"B 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"B 实现了operation5\");​ }}public class D implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"D 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"D 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend2(Interface1 inteface1){​ inteface1.operation2();​ }​ public void depend3(Interface1 inteface1){​ inteface1.operation3();​ }}public class C {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend4(Interface1 inteface1){​ inteface1.operation4();​ }​ public void depend5(Interface1 inteface1){​ inteface1.operation5();​ }} 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D。如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。 按照接口隔离原则应当如下处理： 将接口Interface1拆分成几个接口（这里我们拆分成3个接口），类Ａ和类Ｃ分别与他们需要的接口建立依赖关系。 改造后：改进的UML类图如下： 改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public interface Interface1 {​ void operation1();}public interface Interface2 {​ void operation2();​ void operation3();}public interface Interface3 {​ void operation4();​ void operation5();}public class B implements Interface1,Interface2 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }}public class D implements Interface1,Interface3 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend2(Interface2 inteface){​ inteface.operation2();​ }​ public void depend3(Interface2 inteface){​ inteface.operation3();​ }}public class C {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend4(Interface3 inteface){​ inteface.operation4();​ }​ public void depend5(Interface3 inteface){​ inteface.operation5();​ }} 测试代码如下： 12345678910111213141516171819202122public static void main(String[] args) {​ A a = new A();​ a.depend1(new B()); //A 类通过接口去依赖(使用)B​ a.depend2(new B());​ a.depend3(new B());​ C c = new C();​ c.depend1(new D());//C 类通过接口去依赖(使用)D​ c.depend4(new D());​ c.depend5(new D());​ } 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/17/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"},{"title":"数组_88合并两个有序数组","text":"给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。 &nbsp; 说明: 初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。 你可以假设&nbsp;nums1&nbsp;有足够的空间（空间大小大于或等于&nbsp;m + n）来保存 nums2 中的元素。 &nbsp; 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出:&nbsp;[1,2,2,3,5,6] Related Topics数组双指针 这道题还是蛮简单的，只要注意参数m 和 n 就好。 12345678910111213141516171819202122232425262728293031323334class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int p=m+n; while(m&gt;0||n&gt;0){ p--; //exist m and n ,compare if(m&gt;0&amp;&amp;n&gt;0){ if(nums1[m-1]&gt;nums2[n-1]){ nums1[p] = nums1[m - 1]; m--; }else{ nums1[p] = nums2[n - 1]; n--; } continue; } //only exits m,move m if(m&gt;0){ nums1[p] = nums1[m - 1]; m--; continue; } //only exits n,move n if(n&gt;0){ nums1[p] = nums2[n - 1]; n--; continue; } } }}","link":"/2020/05/23/%E6%95%B0%E7%BB%84_88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"数组_66加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 1234567891011121314public int[] plusOne(int[] digits) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; digits.length; i++) { sb.append(digits[i]); } String s = sb.toString(); BigDecimal value = new BigDecimal(s); char[] chars = String.valueOf(value.add(new BigDecimal(1))).toCharArray(); int[] sum = new int[chars.length]; for (int i = 0; i &lt; chars.length; i++) { sum[i] = ( chars[i]-'0'); } return sum;} 这是我原来三天前的思路。想转成整数然后相加，把计算交给程序，奈何随着输入的数组长度越来越长，总是会溢出，然后我看了思路，觉得自己太傻，就为了自己省事，唉，在做算法题啊。 以下是我看完思路后，三天后独立完成的。 1234567891011121314151617public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i &gt;= 0; i--) { if (digits[i]+1&lt;10){ digits[i]=digits[i]+1; break; }else { digits[i]=0; } } if (digits[0] == 0) { int[] ints = new int[digits.length + 1]; ints[0]=1; return ints; } return digits; }","link":"/2020/05/21/%E6%95%B0%E7%BB%84_66%E5%8A%A0%E4%B8%80/"},{"title":"里氏替换原则","text":"OO中的继承性的思考和说明 继承包含这样一层含义： 父类中凡是已经实现好的方法，实际上是在设计规范，虽然它不强制要求所有子类必须遵循这些规范，但是如果子类如果对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。 继承给程序设计带来便利的同时，也带来了弊端。比如使用了继承，父类的任何改动都得考虑到所有继承的子类，并且父类修改后，所有涉及到的子类功能都有可能产生故障。 问题提出：如何正确使用继承？ 里氏替换原则 OO中的继承性的思考和说明 里氏替换原则（Liskov Substitution Principle）在1988年，由麻省理工学院的一位姓里的女士提出的。 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方都必须能透明地使用其子类对象。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 反例：12345678910111213141516171819202122232425262728293031323334public class A { //a + b public Integer function1(int a,int b){ return a + b; }}public class B extends A{ //change function1 of A by accident @Override public Integer function1(int a, int b) { return a-b; }}public class Main { public static void main(String[] args) { A a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); A b = new B(); System.out.println(\"1+2=\"+b.function1(1, 2)); //没想到B 已经改了继承的方法，造成结果错误 System.out.println(\"2+3=\"+b.function1(2, 3)); }} 测试结果： 解决方法： B类不小心改了A类的方法，导致调用出错。在实际开发中，我们常常会通过修改父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系复用性比较差。 通用的做法是：将原来的父类和子类都继承一个更加通用的基类，原有的继承关系去掉，采用依赖，聚合，组合等方式代替。 改进后的方案如下： 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Base { public abstract Integer function1(int a, int b);}public class A extends Base{ //a + b @Override public Integer function1(int a,int b){ return a + b; }}public class B extends Base { A a = new A(); //a-b @Override public Integer function1(int a, int b) { return a-b; } public Integer function2(int i, int j){ return a.function1(i, j); }}public class Main { public static void main(String[] args) { Base a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); Base b = new B(); System.out.println(\"1-2=\"+b.function1(1, 2)); System.out.println(\"2-3=\"+b.function1(2, 3)); }} 总之，里氏替换原则告诉我们，子类中尽量不要重写父类的方法！ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns","link":"/2020/05/23/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"},{"title":"算法前言","text":"根据up主小齐的经验，她的第一阶段是根据MIT的算法导论课的课程顺序调整Leetcode的刷题顺序的，如下就是该课程的排课表： 截止到目前[20200519]，杰哥已经刷了13道题了（easy难度，题号从小到大的排序），还是比较弱鸡的。杰哥也会根据这个排课表重新调整刷题顺序的，需要继续努力啊，少年。 第一阶段刷题： 数组： Leetcode no.53 最大子序和 Leetcode no.66 加1 2020年06月01日加入了 91算法群,和小伙伴一起刷算法题。以下是每天刷题记录: 2020-06-01 - 66. 加一 2020-06-02 - 75. 颜色分类 2020-06-03 - 1381. 设计一个支持增量操作的栈","link":"/2020/05/19/%E7%AE%97%E6%B3%95%E5%89%8D%E8%A8%80/"},{"title":"依赖倒转原则","text":"基本介绍： 依赖倒转原则（Dependence Inversion Principle）是指： 细节应该依赖于抽象 本质上是面向接口编程 依赖倒转是基于这样的设计理念： 相对于细节的多变性，抽象的东西要稳定得多。在Java中,抽象是指接口或者抽象类，细节就是对应的实现类 使用接口或者抽象类的目的在于制定好规范，不涉及任何的具体实现。把需要具体操作的任务交给他们对应的实现类去进行。 反例：123456789101112131415161718192021public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Sms { public String getMsg(){ return \"hello world\"; }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 分析： Mobile类的receiveMsg方法参数直接面向具体对象，如果以后该Mobile对象还需接收其他类型的数据，比如彩信之类的，扩展非常不方便。 正例：我们面向接口编程即可解决这样扩展的需求： 1234567891011121314151617181920212223242526272829303132333435public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用实例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 2. 构造方法传递3. setter 方法传递","link":"/2020/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E8%A8%80/"}],"tags":[{"name":"刷算法题","slug":"刷算法题","link":"/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/tags/tomcat%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"刷算法题","slug":"刷算法题","link":"/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/categories/tomcat%E6%BA%90%E7%A0%81/"}]}