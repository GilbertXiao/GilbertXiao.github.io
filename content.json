{"pages":[{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"设计模式 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 设计模式(顺序已经整理好) 1 设计模式前言 软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 1 单一职责原则 对类来说，即一个类只负责一项职责。 1 接口隔离原则 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 1 依赖倒转原则 细节应该依赖抽象; 依赖倒转(倒置)的本质是面向接口编程 1 里氏替换原则 子类中尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 1 开闭原则 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 1 迪米特法则 一个对象应该对其他对象保存最少的了解 1 合成复用原则 尽量使用合成/聚合的方式，而不是使用继承 1 单例模式 单例模式确保一个类只有一个实例，并提供一个全局访问点。 1 工厂方法模式 在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做，这个核心类则变成一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 1 抽象工厂模式 抽象工厂模式面对的问题是多个产品等级结构的设计。 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/designPattern/index.html"},{"title":"","text":"源码 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 Tomcat8.5.50源码环境搭建 学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/code-source/index.html"},{"title":"","text":"漫画算法 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 漫画算法(顺序已经整理好) 1 漫画算法 漫画算法 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/readings/ComicAlgorithm.html"},{"title":"","text":"刷算法题 .demo { background: transparent; padding: 2em 0; display: flex; justify-content: center; } .main-timeline { width: 80%; margin: 0px auto; margin-top: 20px !important; position: relative; } .main-timeline:before { content: \"\"; display: block; width: 2px; height: 100%; background: rgba(37, 48, 59, 0.7); margin: 0 0 0 -1px; position: absolute; top: 0; left: 50%; } .content h2:not(:first-child) { margin-top: 0px; } .main-timeline .timeline { width: 100%; margin-bottom: 20px; position: relative; border-left: 0px; margin-left: 0px; padding-left: 0px; } .main-timeline .timeline:after { content: \"\"; display: block; clear: both; } .main-timeline .timeline-content { width: 40%; float: left; margin: -10px 0 0 0; border-radius: 6px; } .timeline-content .description { border: 1px solid #dedede; } .main-timeline .date { display: block; width: 70px; height: 70px; line-height: 70px; border-radius: 50%; background: #25303b; padding: 0px 0; margin: 0 0 0 -36px; position: absolute; top: 0; left: 50%; font-size: 12px; font-weight: 900; text-transform: uppercase; color: rgba(255, 255, 255, 0.5); border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 7px #25303b; } .main-timeline .date span { display: block; text-align: center; } .main-timeline .day, .main-timeline .year { font-size: 10px; } .main-timeline .month { font-size: 18px; } .main-timeline .title { padding: 15px; margin: 0; font-size: 20px; color: #fff; text-transform: none; letter-spacing: -1px; border-radius: 6px 6px 0 0; position: relative; } .main-timeline .title:after { content: \"\"; width: 10px; height: 10px; position: absolute; top: 20px; right: -5px; transform: rotate(-45deg); } .main-timeline .description { padding: 15px; margin: 0; font-size: 14px; color: #656565; background: #fff; border-radius: 0 0 6px 6px; } .main-timeline .timeline:nth-child(2n+2) .timeline-content { float: right; } .main-timeline .timeline:nth-child(2n+2) .title:after { left: -5px; } .main-timeline .timeline:nth-child(4n+1) .title, .main-timeline .timeline:nth-child(4n+1) .title:after { background: #9f84c4; } .main-timeline .timeline:nth-child(4n+2) .title, .main-timeline .timeline:nth-child(4n+2) .title:after { background: #02a2dd; } .main-timeline .timeline:nth-child(4n+3) .title, .main-timeline .timeline:nth-child(4n+3) .title:after { background: #58b25e; } .main-timeline .timeline:nth-child(4n+4) .title, .main-timeline .timeline:nth-child(4n+4) .title:after { background: #eab715; } @media only screen and (max-width: 990px) { .main-timeline { width: 100%; } } @media only screen and (max-width: 767px) { .main-timeline:before, .main-timeline .date { left: 6%; } .main-timeline .timeline-content { width: 85%; float: right; } .main-timeline .title:after { left: -5px; } } @media only screen and (max-width: 480px) { .main-timeline:before, .main-timeline .date { left: 12%; } .main-timeline .timeline-content { width: 75%; } .main-timeline .date { width: 60px; height: 60px; margin-left: -30px; } .main-timeline .month { font-size: 14px; } } 刷算法题(顺序已经整理好) 1 算法前言 刷题前述 1 66. 加一 为什么又是加一？因为这是加入算法组织的第一天出的题~ 1 75. 颜色分类 给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 1 1381. 设计一个支持增量操作的栈 实现自定义栈类 1 394. 字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。 1 232. 用栈实现队列 用栈实现队列 1 380. 常数时间插入、删除和获取随机元素 常数时间插入、删除和获取随机元素 1 206. 反转链表 反转链表 1 430. 扁平化多级双向链表 扁平化多级双向链表 1 109. 有序链表转换二叉搜索树 有序链表转换二叉搜索树 1 160. 相交链表 相交链表 1 142. 环形链表 II 环形链表II 1 146. LRU缓存机制 LRU缓存机制 1 104. 二叉树的最大深度 二叉树的最大深度 1 100. 相同的树 给定两个二叉树，编写一个函数来检验它们是否相同。 1 129. 求根到叶子节点数字之和 求根到叶子节点数字之和 1 513. 找树左下角的值 找树左下角的值 1 105. 从前序与中序遍历序列构造二叉树 从前序与中序遍历序列构造二叉树 1 124. 二叉树中的最大路径和 二叉树中的最大路径和 1 1. 两数之和 两数之和 1 447. 回旋镖的数量 回旋镖的数量 1 36. 有效的数独 有效的数独 1 645. 错误的集合 错误的集合 1 面试题 04.01. 节点间通路 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 1 149. 直线上最多的点 给定一个二维平面，平面上有n个点，求最多有多少个点在同一条直线上。 1 11. 盛最多水的容器 盛最多水的容器 1 875. 爱吃香蕉的珂珂 爱吃香蕉的珂珂 1 26. 删除排序数组中的重复项 删除排序数组中的重复项 1 167. 两数之和II-输入有序数组 两数之和II-输入有序数组 1 42. 接雨水 给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 1 面试题 17.11. 单词距离 有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。 1 581. 最短无序连续子数组 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 1 78. 子集 给定一组不含重复元素的整数数组&nbsp;nums，返回该数组所有可能的子集（幂集）。 1 78. 子集 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。 1 20. 有效的括号 | 32. 最长有效括号 20. 有效的括号 | 32. 最长有效括号 1 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 1 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 1 144. 二叉树的前序遍历 | 94. 二叉树的中序遍历 | 145. 二叉树的后序遍历 | 102. 二叉树的层序遍历 144. 二叉树的前序遍历 | 94. 二叉树的中序遍历 | 145. 二叉树的后序遍历 | 102. 二叉树的层序遍历 1 208. 实现Trie 实现一个 Trie (前缀树)，包含&nbsp;insert,&nbsp;search, 和&nbsp;startsWith&nbsp;这三个操作。 1 677. 键值映射 实现一个 MapSum 类里的两个方法，insert&nbsp;和&nbsp;sum。 1 面试题17.17 多次搜索 给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。 1 547. 朋友圈 输出所有学生中的已知的朋友圈总数。 1 924. 尽量减少恶意软件的传播 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)，&nbsp;则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。 1 1319. 连通网络的操作次数 请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回&nbsp;-1 。&nbsp; 完 谢谢浏览！ test let els = document.getElementsByClassName(\"month\"); for (let i = 0; i < els.length; i++) { els[i].innerHTML = i + 1; }","link":"/algorithm/index.html"}],"posts":[{"title":"104. 二叉树的最大深度","text":"给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明:&nbsp;叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度&nbsp;3 。 Related Topics树深度优先搜索 用递归就好, 时间复杂度O(n)，每个节点都要遍历一次，空间复杂度O(1)，没有创建新的容器。。。 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，其中 N 是结点的数量。空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O((log(N))。 12345678class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right))+1; }} 91算法打卡第十三天参考答案","link":"/2020/06/13/104_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"105. 从前序与中序遍历序列构造二叉树","text":"根据一棵树的前序遍历与中序遍历构造二叉树。注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder =&nbsp;[3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 Related Topics树深度优先搜索数组 看了解题思路，然后根据思路写代码。。。时间复杂度O(mn)，最坏情况是O(n*n)，空间复杂度O(n) 12345678910111213141516171819202122232425262728 public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length == 0) { return null; } if (preorder.length == 1) { return new TreeNode(preorder[0]); } int rootVal = preorder[0]; TreeNode tempHead = new TreeNode(rootVal); int rootInOrderIndex = 0; for (int j = 0; j &lt; inorder.length; j++) { if (inorder[j] == rootVal) { rootInOrderIndex = j; break; } } int[] leftPreOrder = new int[rootInOrderIndex]; int[] leftInOrder = new int[rootInOrderIndex]; int[] rightPreOrder = new int[inorder.length - rootInOrderIndex - 1]; int[] rightInOrder = new int[inorder.length - rootInOrderIndex - 1]; System.arraycopy(preorder, 1, leftPreOrder, 0, rootInOrderIndex); System.arraycopy(inorder, 0, leftInOrder, 0, rootInOrderIndex); System.arraycopy(preorder, rootInOrderIndex + 1, rightPreOrder, 0, inorder.length - rootInOrderIndex - 1); System.arraycopy(inorder, rootInOrderIndex + 1, rightInOrder, 0, inorder.length - rootInOrderIndex - 1); tempHead.left = buildTree(leftPreOrder, leftInOrder); tempHead.right = buildTree(rightPreOrder, rightInOrder); return tempHead;} 91算法打卡第十七天参考答案","link":"/2020/06/17/105_%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"100. 相同的树","text":"给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例&nbsp;1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例&nbsp;3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false Related Topics树深度优先搜索 时间复杂度 O(N),N为节点数量，每个节点都会访问到。空间复杂度：最坏情况是O(N)，比如只有左节点。最好的情况是O(log(N))，完全平衡二叉树。 1234567891011121314class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if ((p == null &amp;&amp; q != null)||(p != null &amp;&amp; q == null)) { return false; } if (p == null &amp;&amp; q == null) { return true; } if (p.val != q.val) { return false; } return isSameTree(p.left, q.left)&amp;&amp;isSameTree(p.right, q.right); }} 91算法打卡第十四天参考答案","link":"/2020/06/14/100_%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"},{"title":"1319. 连通网络的操作次数","text":"用以太网线缆将&nbsp;n&nbsp;台计算机连接成一个网络，计算机的编号从&nbsp;0&nbsp;到&nbsp;n-1。线缆用&nbsp;connections&nbsp;表示，其中&nbsp;connections[i] = [a, b]&nbsp;连接了计算机&nbsp;a&nbsp;和&nbsp;b。 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。 给你这个计算机网络的初始布线&nbsp;connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回&nbsp;-1 。&nbsp; &nbsp; 示例 1： 输入：n = 4, connections = [[0,1],[0,2],[1,2]] 输出：1 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] 输出：2 示例 3： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] 输出：-1 解释：线缆数量不足。 示例 4： 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] 输出：0 &nbsp; 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1]&nbsp;&lt; n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 Related Topics深度优先搜索广度优先搜索并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { public int makeConnected(int n, int[][] connections) { int allConnections = connections.length; if (allConnections &lt; n - 1) { return -1; } UnionFindSet unionFindSet = new UnionFindSet(n); for (int i = 0; i &lt; connections.length; i++) { unionFindSet.unionSet(connections[i][0], connections[i][1]); } return unionFindSet.getSumOfSet()-1; }}class UnionFindSet{ private int[] parent; private int[] rank; private int sumOfSet; public UnionFindSet(int num) { this.parent = new int[num]; this.rank = new int[num]; this.sumOfSet = num; for (int i = 0; i &lt; parent.length; i++) { parent[i] = i; } } public int findSet(int x) { if (x != parent[x]) { parent[x] = findSet(parent[x]); } return parent[x]; } public void unionSet(int x, int y) { int rootX = findSet(x); int rootY = findSet(y); if (rootX == rootY) { return; } if (rank[rootX] &gt; rank[rootY]) { parent[rootY] = rootX; }else{ parent[rootX] = rootY; if (rank[rootX] == rank[rootY]) { rank[rootY]++; } } sumOfSet--; } public int getSumOfSet(){ return sumOfSet; }} 91算法打卡第四十六天参考答案","link":"/2020/07/16/1319_%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"},{"title":"109. 有序链表转换二叉搜索树","text":"给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 Related Topics深度优先搜索链表 看答案的，自己想复杂了，对树这种结构掌握不太好。边界条件要注意。 时间复杂度O(n)，空间复杂度O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;Integer&gt; integerList; public Solution(){ this.integerList=new ArrayList&lt;&gt;(); } private void changeToList(ListNode node) { while (node != null) { this.integerList.add(node.val); node = node.next; } } public TreeNode sortedListToBST(ListNode head) { if (head == null) { return null; } changeToList(head); TreeNode treeNode = getBST(0, this.integerList.size() - 1); return treeNode; } private TreeNode getBST(int start, int end) { if (start &gt; end) { return null; } int mid = (start + end) &gt;&gt; 1; int midVal = integerList.get(mid); TreeNode treeNode = new TreeNode(midVal); if (start == end) { return treeNode; } TreeNode left = getBST(start, mid-1); TreeNode right = getBST(mid+1, end); treeNode.left = left; treeNode.right = right; return treeNode; } 91算法打卡第九天参考答案","link":"/2020/06/09/109_%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"11. 盛最多水的容器","text":"给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点&nbsp;(i,&nbsp;ai) 。在坐标内画 n 条垂直线，垂直线 i&nbsp;的两个端点分别为&nbsp;(i,&nbsp;ai) 和 (i, 0)。找出其中的两条线，使得它们与&nbsp;x&nbsp;轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且&nbsp;n&nbsp;的值至少为 2。 &nbsp; 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。 &nbsp; 示例： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 Related Topics数组双指针 一开始的思路是两个for循环，时间复杂度O(n^2),空间复杂度O(1)。 123456789101112131415public int maxArea(int[] height) { if (height == null || height.length &lt; 2) { return 0; } int max = 0; for (int i = 0; i &lt; height.length-1; i++) { for (int j = i + 1; j &lt; height.length; j++) { int min = Math.min(height[i], height[j]); int bottom = j - i; int area = bottom * min; max = Math.max(area, max); } } return max;} 后面看了题解，嗯，双指针原来是这样的，我以为我的方法也是双指针。。。时间复杂度O(n),空间复杂度O(1) 1234567891011121314151617public int maxArea(int[] height) { int max = 0; if (height == null || height.length &lt; 2) { return max; } int left = 0, right = height.length - 1; while (left &lt; right) { int area = Math.min(height[left],height[right])*(right-left); max = Math.max(area, max); if (height[left] &lt;= height[right]) { left++; }else { right--; } } return max;} 祝大家端午安康~ 91算法打卡第二十五天参考答案","link":"/2020/06/25/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"124. 二叉树中的最大路径和","text":"给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3 输出: 6 示例&nbsp;2: 输入: [-10,9,20,null,null,15,7] &nbsp; -10 &nbsp; &nbsp;/ \\ &nbsp; 9 &nbsp;20 &nbsp; &nbsp; / &nbsp;\\ &nbsp; &nbsp;15 &nbsp; 7 输出: 42 Related Topics树深度优先搜索 昨晚看了答案的，今天再独立做了一次，还是比较久。。。时间复杂度O(n)，空间复杂度O(log(N))，堆栈的个数。 12345678910111213141516171819202122232425int max = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) { getMaxPath(root); return max;}private int getMaxPath(TreeNode root) { if (root == null) { return 0; } int lefMax = getMaxPath(root.left); int rightMax = getMaxPath(root.right); int nodeVal = root.val; int allPathVal = Math.max(lefMax, 0) + Math.max(rightMax, 0) + nodeVal; max = Math.max(max, allPathVal); return nodeVal + Math.max(Math.max(lefMax, rightMax), 0);} 91算法打卡第十八天参考答案","link":"/2020/06/19/124_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"1381. 设计一个支持增量操作的栈","text":"请你设计一个支持下述操作的栈。 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。 void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。 int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。 void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 &nbsp; 示例： 输入： [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 输出： [null,null,null,2,null,null,null,null,null,103,202,201,-1] 解释： CustomStack customStack = new CustomStack(3); // 栈是空的 [] customStack.push(1); // 栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.pop(); // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.push(3); // 栈变为 [1, 2, 3] customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4 customStack.increment(5, 100); // 栈变为 [101, 102, 103] customStack.increment(2, 100); // 栈变为 [201, 202, 103] customStack.pop(); // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202] customStack.pop(); // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201] customStack.pop(); // 返回 201 --&gt; 返回栈顶值 201，栈变为 [] customStack.pop(); // 返回 -1 --&gt; 栈为空，返回 -1 &nbsp; 提示： 1 &lt;= maxSize &lt;= 1000 1 &lt;= x &lt;= 1000 1 &lt;= k &lt;= 1000 0 &lt;= val &lt;= 100 每种方法 increment，push 以及 pop 分别最多调用 1000 次 Related Topics栈设计 这道题感觉不是很难，一看到就有思路了。首先考虑数据结构，栈不行，不然在incr 这个方法会比较麻烦；链表不行，因为查找比较麻烦；所以就选择数组。push方法的时间复杂度为O(1), pop方法的时间复杂度为O(1)，incr 方法的时间复杂度为O(n)。空间复杂度，O(n)， 用了一个数组。 1234567891011121314151617181920212223242526272829303132333435class CustomStack { private Integer[] stack; private int index; private int maxSize; public CustomStack(int maxSize) { this.maxSize = maxSize; this.index = -1; this.stack = new Integer[maxSize]; } public void push(int x) { if (index &gt;= maxSize - 1) { return; } this.stack[++index] = x; } public int pop() { if (index == -1) { return -1; } int result = this.stack[index]; this.stack[index--] = null; return result; } public void increment(int k, int val) { int min = k &gt;= index + 1 ? index + 1 : k; for (int i = 0; i &lt; min; i++) { this.stack[i] += val; } } } 91算法打卡第三天参考答案","link":"/2020/06/03/1381_%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/"},{"title":"129. 求根到叶子节点数字之和","text":"给定一个二叉树，它的每个结点都存放一个&nbsp;0-9&nbsp;的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明:&nbsp;叶子节点是指没有子节点的节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3 输出: 25 解释: 从根到叶子节点路径 1-&gt;2 代表数字 12. 从根到叶子节点路径 1-&gt;3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2: 输入: [4,9,0,5,1] 4 / \\ 9 0 &nbsp;/ \\ 5 1 输出: 1026 解释: 从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495. 从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491. 从根到叶子节点路径 4-&gt;0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. Related Topics树深度优先搜索 今天的题看了答案才知道怎么做的，花了很长的时间唉。时间复杂度O(N)，N为节点数量空间复杂度O(logN) 12345678910111213141516class Solution { public int sumNumbers(TreeNode root) { return getSum(root, 0); } private int getSum(TreeNode root, int sum) { if (root == null) { return 0; } int temp = sum * 10 + root.val; if (root.left == null &amp;&amp; root.right == null) { return temp; } return getSum(root.left, temp) + getSum(root.right, temp); }} 91算法打卡第十五天参考答案","link":"/2020/06/15/129_%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"},{"title":"142. 环形链表 II","text":"给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 &nbsp; 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例&nbsp;2： 输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 &nbsp; 进阶： 你是否可以不用额外空间解决此题？ Related Topics链表双指针 第一种，暴力解法：时间复杂度 O(n)，空间复杂度O(n) 123456789101112131415public ListNode detectCycle(ListNode head) { if (head == null) { return null; } Set&lt;ListNode&gt; listNodes = new HashSet&lt;&gt;(); ListNode tempHead = head; while (tempHead != null) { if (listNodes.contains(tempHead)) { return tempHead; } listNodes.add(tempHead); tempHead = tempHead.next; } return null; } 第二种，快慢指针追及问题时间复杂度 O(n)，空间复杂度O(1) 12345678910111213141516171819202122232425public ListNode detectCycle(ListNode head) { if (head == null) { return null; } ListNode slowNode = head; ListNode fastNode = head; while (fastNode != null) { if (fastNode.next != null &amp;&amp; fastNode.next.next != null) { fastNode = fastNode.next.next; } else { return null; } slowNode = slowNode.next; if (slowNode == fastNode) { break; } } ListNode restartNode = head; while (restartNode != slowNode) { restartNode=restartNode.next; slowNode = slowNode.next; } return restartNode; } 91算法打卡第十一天参考答案","link":"/2020/06/11/142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"},{"title":"144. 二叉树的前序遍历 | 94. 二叉树的中序遍历 | 145. 二叉树的后序遍历 | 102. 二叉树的层序遍历","text":"给定一个二叉树，返回它的&nbsp;前序&nbsp;遍历。 &nbsp;示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶:&nbsp;递归算法很简单，你可以通过迭代算法完成吗？ Related Topics栈树 时间复杂度：O(n)空间复杂度：O(n) 12345678910List list = new ArrayList();public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if (root == null) { return new ArrayList(); } list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return list;} 94. 二叉树的中序遍历给定一个二叉树，返回它的中序&nbsp;遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 进阶:&nbsp;递归算法很简单，你可以通过迭代算法完成吗？ Related Topics栈树哈希表 时间复杂度：O(n)空间复杂度：O(n) 12345678910List list = new ArrayList();public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if (root == null) { return new ArrayList&lt;&gt;(); } inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); return list;} 145. 二叉树的后序遍历给定一个二叉树，返回它的 后序&nbsp;遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 进阶:&nbsp;递归算法很简单，你可以通过迭代算法完成吗？ Related Topics栈树 时间复杂度：O(n)空间复杂度：O(n) 12345678910List list = new ArrayList();public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if (root == null) { return new ArrayList&lt;&gt;(); } postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list;} 102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 &nbsp; 示例： 二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] Related Topics树广度优先搜索 时间复杂度：O(n)空间复杂度：O(n) 12345678910111213141516171819202122232425List&lt;List&lt;Integer&gt;&gt; list = new ArrayList();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if (root == null) { return new ArrayList&lt;&gt;(); } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode treeNode = queue.poll(); integers.add(treeNode.val); if (treeNode.left != null) { queue.offer(treeNode.left); } if (treeNode.right != null) { queue.offer(treeNode.right); } } list.add(integers); } return list;} 91算法打卡第四十天参考答案","link":"/2020/07/10/144_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"146. LRU缓存机制","text":"运用你所掌握的数据结构，设计和实现一个&nbsp; LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 &nbsp; 进阶: 你是否可以在&nbsp;O(1) 时间复杂度内完成这两种操作？ &nbsp; 示例: LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得关键字 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得关键字 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 Related Topics设计 时间复杂度O(1)，空间复杂度O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class LRUCache { int capatity; Node head; Node tail; Map&lt;Integer, Node&gt; map; public LRUCache(int capacity) { this.capatity = capacity; map = new HashMap&lt;&gt;(); head = null; tail = null; } public int get(int key) { if (map.containsKey(key)) { Node node = map.get(key); if (head != node) { removeNode(node); appendHead(node); } return node.val; } return -1; } public void put(int key, int value) { Node node = new Node(key, value); if (head == null &amp;&amp; tail == null) { head = tail = node; } else { Node existNode = map.get(key); if (existNode != null) { removeNode(existNode); }else if (map.size() == capatity) { int tailKey = tail.key; removeNode(tail); map.remove(tailKey); } appendHead(node); } map.put(key, node); } private void appendHead(Node node) { if (head == null) { head = tail = node; }else if (head != node) { Node tempHead = head; head = node; head.next = tempHead; tempHead.pre = head; } } private void removeNode(Node node) { if (head == tail) { head = tail = null; }else{ if (node == head) { head = head.next; node.next = null; head.pre = null; } else if (node == tail) { tail = tail.pre; node.pre = null; tail.next = null; }else{ Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; } } } public class Node { public int key; public int val; public Node next; public Node pre; public Node(int key, int val) { this.key = key; this.val = val; } }}/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 91算法打卡第十二天参考答案","link":"/2020/06/12/146_LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"149. 直线上最多的点","text":"给定一个二维平面，平面上有&nbsp;n&nbsp;个点，求最多有多少个点在同一条直线上。 示例 1: 输入: [[1,1],[2,2],[3,3]] 输出: 3 解释: ^ | | &nbsp; &nbsp; &nbsp; &nbsp;o | &nbsp; &nbsp; o | &nbsp;o &nbsp; +-------------&gt; 0 &nbsp;1 &nbsp;2 &nbsp;3 4 示例&nbsp;2: 输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] 输出: 4 解释: ^ | | o | &nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&nbsp; o | &nbsp;&nbsp;&nbsp;&nbsp; o | &nbsp;o &nbsp; o +-------------------&gt; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp;6 Related Topics哈希表数学 一开始的思路时间复杂度是O(n^2)，觉得不太可能，就看了宝石的答案和官网题解，发现还真是。。。时间复杂度 O(n^2) 嵌套for循环空间复杂度O(n) n为点的数量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public int maxPoints(int[][] points) { if (points == null) { return 0; } if (points.length &lt;= 2) { return points.length; } int max = 0; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; points.length; i++) { int same = 1; for (int j = 0; j &lt; points.length; j++) { if (i == j) { continue; } int x = points[j][0] - points[i][0]; int y = points[j][1] - points[i][1]; if (x == 0 &amp;&amp; y == 0) { same++; continue; } int greatestCommonDivisor = gcd(y, x); String key = &quot;&quot; + y / greatestCommonDivisor + '#' + x / greatestCommonDivisor; Integer value = map.getOrDefault(key, 0) + 1; map.put(key, value); } if (map.isEmpty()) { max = Math.max(max, same); } else { for (Integer value : map.values()) { max = Math.max(max, same + value); } } map.clear(); } return max;}private int gcd(int y, int x) { if (y == x || x == 0) { return y; } if (y == 0) { return x; } if (y / x &lt; 0) { if (y &gt; 0) { return -gcd(y, -x); } return gcd(-y, x); } if ((y &amp; 1) == 0 &amp;&amp; (x &amp; 1) == 0) { return gcd(y &gt;&gt; 1, x &gt;&gt; 1) &lt;&lt; 1; } else if ((y &amp; 1) == 0 &amp;&amp; (x &amp; 1) != 0) { return gcd(y &gt;&gt; 1, x); } else if ((y &amp; 1) != 0 &amp;&amp; (x &amp; 1) == 0) { return gcd(y, x &gt;&gt; 1); } else { int bigger = y &gt; x ? y : x; int smaller = y &gt; x ? x : y; return gcd(bigger - smaller, smaller); }} gcd 借鉴了小灰漫画算法里面的。优化% 取余的效率，可是最后和宝石的时间对比竟然还要差。。。 91算法打卡第二十四天参考答案","link":"/2020/06/24/149_%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9/"},{"title":"160. 相交链表","text":"编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 &nbsp; 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 &nbsp; 示例&nbsp;2： 输入：intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 &nbsp; 示例&nbsp;3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 &nbsp; 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 Related Topics链表 暴力解：时间复杂度O(n),空间复杂度O(n) 12345678910111213141516public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Map&lt;ListNode, Integer&gt; map = new HashMap(); ListNode tempA = headA; ListNode tempB = headB; while (tempA != null) { map.put(tempA, null); tempA = tempA.next; } while (tempB != null) { if (map.containsKey(tempB)) { return tempB; } tempB = tempB.next; } return null; } 第二种思路来自群友，很巧妙的解法。假设有A由a+b组成，B由c+b组成， b为交集部分那么 a+b+c=c+b+a 。以步长为1 同时遍历，最后两者相等即为交集点。时间复杂度O(n),空间复杂度O(1) 1234567891011121314public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode tempA = headA; ListNode tempB = headB; while (tempA != tempB) { tempA = tempA == null ? headB : tempA.next; tempB = tempB == null ? headA : tempB.next; } return tempA; } 91算法打卡第十天参考答案","link":"/2020/06/10/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"title":"1. 两数之和","text":"给定一个整数数组 nums&nbsp;和一个目标值 target，请你在该数组中找出和为目标值的那&nbsp;两个&nbsp;整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 &nbsp; 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] Related Topics数组哈希表 昨晚看了答案的，今天再独立做了一次，还是比较久。。。时间复杂度O(n)，空间复杂度O(log(N))，堆栈的个数。 12345678910111213141516171819202122232425int max = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) { getMaxPath(root); return max;}private int getMaxPath(TreeNode root) { if (root == null) { return 0; } int lefMax = getMaxPath(root.left); int rightMax = getMaxPath(root.right); int nodeVal = root.val; int allPathVal = Math.max(lefMax, 0) + Math.max(rightMax, 0) + nodeVal; max = Math.max(max, allPathVal); return nodeVal + Math.max(Math.max(lefMax, rightMax), 0);} 91算法打卡第十九天参考答案","link":"/2020/06/19/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"167. 两数之和II-输入有序数组","text":"给定一个已按照升序排列&nbsp;的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1&nbsp;必须小于&nbsp;index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 Related Topics数组双指针二分查找 一开始想到的是，leetcode第一道题的解法，时间复杂度O(n)，空间复杂度O(n) 1234567891011121314151617public int[] twoSum(int[] numbers, int target) { if (numbers.length &lt; 2) { return null; } Map&lt;Integer, Integer&gt; integerIntegerHashMap = new HashMap&lt;&gt;(); integerIntegerHashMap.put(numbers[0], 1); for (int i = 1; i &lt; numbers.length; i++) { if (integerIntegerHashMap.containsKey(target - numbers[i])) { return new int[]{integerIntegerHashMap.get(target - numbers[i]), i + 1}; } if (numbers[i] &gt;= target) { break; } integerIntegerHashMap.put(numbers[i], i + 1); } return null;} 这次主题是双指针，当然也要用双指针尝试下，leetcode上第二种方法比第一种方法速度快了很多。应该是第一种方法中的map的containsKey方法拖慢了速度，我记得这个方法的时间复杂度是近似O(1)时间复杂度O(n),空间复杂度O(1) 12345678910111213141516171819public int[] twoSum(int[] numbers, int target) { if (numbers.length &lt; 2) { return null; } int left = 0; int right = numbers.length - 1; while (left &lt; right) { if (numbers[left] + numbers[right] &gt; target) { right--; continue; } if (numbers[left] + numbers[right] &lt; target) { left++; continue; } return new int[]{left+1, right+1}; } return null;} 91算法打卡第二十八天参考答案","link":"/2020/06/28/167_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"206. 反转链表","text":"反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ Related Topics链表 递归递归里面还有while，时间复杂度为O(n^2) 1234567891011121314151617 public ListNode reverseList(ListNode head) { if (head == null) { return null; } if (head!=null&amp;&amp;head.next == null) { return head; } ListNode node = reverseList(head.next); head.next = null; ListNode lastNode = node; while (lastNode.next != null) { lastNode = lastNode.next; } lastNode.next = head; return node; }` 迭代：可以参考讲义的内容将如下内容进行优化，时间复杂度O(n) 1234567891011121314public ListNode reverseList(ListNode head) { ListNode temp = null; if (head == null) { return null; } while (head.next != null) { ListNode tempHead = head; head = head.next; tempHead.next = temp; temp = tempHead; } head.next = temp; return head; } 91算法打卡第七天参考答案","link":"/2020/06/07/206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"208. 实现Trie","text":"实现一个 Trie (前缀树)，包含&nbsp;insert,&nbsp;search, 和&nbsp;startsWith&nbsp;这三个操作。 示例: Trie trie = new Trie(); trie.insert(&quot;apple&quot;); trie.search(&quot;apple&quot;); // 返回 true trie.search(&quot;app&quot;); // 返回 false trie.startsWith(&quot;app&quot;); // 返回 true trie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母&nbsp;a-z&nbsp;构成的。 保证所有输入均为非空字符串。 Related Topics设计字典树 暴力空间复杂度O(n) insert 时间复杂度O(1)，search 时间复杂度O(1) 单词数量少的话，startsWith 时间复杂度O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243Map map;/** * Initialize your data structure here. */public Trie() { map = new HashMap();}/** * Inserts a word into the trie. */public void insert(String word) { if (word == null) { return; } map.put(word, null);}/** * Returns if the word is in the trie. */public boolean search(String word) { return map.containsKey(word);}/** * Returns if there is any word in the trie that starts with the given prefix. */public boolean startsWith(String prefix) { Iterator iterator = map.keySet().iterator(); while (iterator.hasNext()) { String next = (String) iterator.next(); if (next.startsWith(prefix)) { return true; } } return false;} 看群友思路结合Map空间复杂度O(n) insert 时间复杂度O(n)，search 时间复杂度O(n) ，startsWith 时间复杂度O(n) , n 为单词的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778Map&lt;String, Trie&gt; next; //key is all of characterboolean end;/** * Initialize your data structure here. */public Trie() { next = new HashMap(); end = false;}/** * Inserts a word into the trie. */public void insert(String word) { if (word==null) { return; } String[] singleWord = word.split(\"\"); Trie curTrie = this; for (int i = 0; i &lt; singleWord.length; i++) { Map&lt;String, Trie&gt; curTrieMap = curTrie.next; if (curTrieMap == null ) { curTrieMap = new HashMap&lt;&gt;(); } if (!curTrieMap.containsKey(singleWord[i])) { curTrieMap.put(singleWord[i], new Trie()); } curTrie.next = curTrieMap; curTrie = curTrieMap.get(singleWord[i]); } curTrie.end = true;}/** * Returns if the word is in the trie. */public boolean search(String word) { if (word == null) { return false; } String[] singleWord = word.split(\"\"); Trie curTrie = this; for (int i = 0; i &lt; singleWord.length; i++) { Map&lt;String, Trie&gt; next = curTrie.next; if (next == null) { return false; } curTrie = next.get(singleWord[i]); if (curTrie == null) { return false; } } return curTrie.end;}/** * Returns if there is any word in the trie that starts with the given prefix. */public boolean startsWith(String word) { if (word == null) { return false; } String[] singleWord = word.split(\"\"); Trie curTrie = this; for (int i = 0; i &lt; singleWord.length; i++) { Map&lt;String, Trie&gt; next = curTrie.next; if (next == null) { return false; } curTrie = next.get(singleWord[i]); if (curTrie == null) { return false; } } return true;} 群友思路数组查询速度快了很多啊。。。 空间复杂度O(n) insert 时间复杂度O(n)，search 时间复杂度O(n) ，startsWith 时间复杂度O(n) , n 为单词的长度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Trie[] next; // store a - zboolean end;/** * Initialize your data structure here. */public Trie() { next = new Trie[26]; //store a - z end = false;}/** * Inserts a word into the trie. */public void insert(String word) { if (word == null) { return; } char[] chars = word.toCharArray(); Trie curTrie = this; for (int i = 0; i &lt; chars.length; i++) { int index = chars[i] - 'a'; if (curTrie.next[index] == null) { curTrie.next[index] = new Trie(); } curTrie = curTrie.next[index]; } curTrie.end = true; // the word is end}/** * Returns if the word is in the trie. */public boolean search(String word) { if (word == null) { return false; } char[] chars = word.toCharArray(); Trie curTrie = this; for (int i = 0; i &lt; chars.length; i++) { int index = chars[i] - 'a'; if (curTrie.next[index] == null) { return false; } curTrie = curTrie.next[index]; } return curTrie.end;}/** * Returns if there is any word in the trie that starts with the given prefix. */public boolean startsWith(String word) { if (word == null) { return false; } char[] chars = word.toCharArray(); Trie curTrie = this; for (int i = 0; i &lt; chars.length; i++) { int index = chars[i] - 'a'; if (curTrie.next[index] == null) { return false; } curTrie = curTrie.next[index]; } return true;} 91算法打卡第四十一天参考答案","link":"/2020/07/11/208_%E5%AE%9E%E7%8E%B0Trie/"},{"title":"20. 有效的括号 | 32. 最长有效括号","text":"给定一个只包括 '('，')'，'{'，'}'，'['，']'&nbsp;的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例&nbsp;2: 输入: &quot;()[]{}&quot; 输出: true 示例&nbsp;3: 输入: &quot;(]&quot; 输出: false 示例&nbsp;4: 输入: &quot;([)]&quot; 输出: false 示例&nbsp;5: 输入: &quot;{[]}&quot; 输出: true Related Topics栈字符串 第一种思路，用栈解答时间复杂度O(n)，空间复杂度O(n) 1234567891011121314151617181920212223242526272829303132public boolean isValid(String s) { if (s.length() == 0) { return true; } if (s.length() % 2 == 1) { return false; } Deque&lt;Character&gt; chars = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{') { chars.push(s.charAt(i)); continue; } if (chars.size() == 0 || getCharMapping(chars.pop()) != s.charAt(i)) { return false; } } return chars.isEmpty();}char getCharMapping(char c) { switch (c) { case '(': return ')'; case '[': return ']'; case '{': return '}'; default: throw new IllegalArgumentException(\"invalid char\"); }} 第二种思路用正则，时间复杂度O(n)，空间复杂度O(1) 12345678public boolean isValid(String s) { while (s.contains(\"{}\") || s.contains(\"[]\") || s.contains(\"()\")) { s = s.replaceAll(\"\\\\{}\" , \"\"); s = s.replaceAll(\"\\\\[]\" , \"\"); s = s.replace(\"()\", \"\"); } return s.length() == 0;} 32. 最长有效括号给定一个只包含 '('&nbsp;和 ')'&nbsp;的字符串，找出最长的包含有效括号的子串的长度。 示例&nbsp;1: 输入: &quot;(()&quot; 输出: 2 解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 输入: &quot;)()())&quot; 输出: 4 解释: 最长有效括号子串为 &quot;()()&quot; Related Topics字符串动态规划 91算法打卡第三十七天参考答案","link":"/2020/07/07/20_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"title":"232. 用栈实现队列","text":"使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 -- 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 Related Topics栈设计 用了两个栈，一个是对外输出栈stack（里面的元素一直符合先入先出），一个是备用栈bakStack。当push操作时，先看下stack是否为空，stack不为空则把元素push到bakStack中。当pop操作时，先把stack里面的元素pop出来，然后再判断stack是否为空，如果stack为空，这时候把bakStack的元素全部补充进stack，注意，这步操作后，stack的元素为正序，即符合先入先出了。 空间复杂度 O(n)，时间复杂度 push 操作O(1)， pop 操作 O(n)，peek操作O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041class MyQueue { Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; bakStack; /** Initialize your data structure here. */ public MyQueue() { this.stack=new Stack(); this.bakStack = new Stack(); } /** Push element x to the back of queue. */ public void push(int x) { if(!stack.isEmpty()){ bakStack.push(x); }else{ stack.push(x); } } /** Removes the element from in front of queue and returns that element. */ public int pop() { int temp = stack.pop(); if(stack.isEmpty()){ while(!bakStack.isEmpty()){ stack.push(bakStack.pop()); } } return temp; } /** Get the front element. */ public int peek() { return stack.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack.isEmpty(); }} 91算法打卡第五天参考答案","link":"/2020/06/05/232_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"42. 接雨水","text":"给定&nbsp;n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。&nbsp;感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 Related Topics栈数组双指针 看了小漾童鞋的伪代码思路才恍然大悟的。 伪代码如下： 初始化左右指针left、right指向数组头尾； 初始化左最大高度maxleft=0,右最大高度maxRight =0 当left &lt; = right 重复以下循环： 当左高度height[left] &lt; 右高度height[right] 此时关注点在左指针这边，因为它目前为低高度，能不能盛水取决于这边 当左最大高度maxleft&lt; 左高度height[left] 此时盛不了水，就令左最大高度maxleft= 左高度height[left] 否则 可以盛水，sum+=maxleft-height[left] left++ 否则 此时关注点在右指针这边，因为它目前为低高度，能不能盛水取决于这边 当右最大高度maxRight&lt; 右高度height[right] 此时盛不了水，就令右最大高度maxRight= 右高度height[right] 否则 可以盛水，sum+=maxRight-height[right] right-- 12345678910111213141516171819202122232425public int trap(int[] height) { int left = 0; int right = height.length - 1; int maxleft = 0; int maxRight = 0; int sum = 0; while (left &lt;= right) { if (height[left] &lt; height[right]) { if (maxleft &lt; height[left]) { maxleft = height[left]; } else { sum += maxleft - height[left]; } left++; } else { if (maxRight &lt; height[right]) { maxRight = height[right]; } else { sum += maxRight - height[right]; } right--; } } return sum;} 91算法打卡第二十九天参考答案","link":"/2020/06/29/42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"title":"380. 常数时间插入、删除和获取随机元素","text":"设计一个支持在平均&nbsp;时间复杂度 O(1)&nbsp;下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 : // 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.getRandom(); Related Topics设计数组哈希表 有想到数组加hashmap，但是一直没想到remove掉数组中的随机某个数后，怎么很好的填补这个空缺，以及纠结这个随机数不连贯了怎么办的问题。最后无奈看了小伙伴的解答，恍然大悟，拿最后一个数去填补，而不是我一开始设想的下次insert再去填补。。。get 123456789101112131415161718192021222324252627282930313233343536373839404142class RandomizedSet { Map&lt;Integer, Integer&gt; map; List&lt;Integer&gt; list; Random random = new Random(); /** Initialize your data structure here. */ public RandomizedSet() { map = new HashMap(); list = new ArrayList(); } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) { Integer result = map.get(val); if (result == null) { list.add(val); map.put(val, list.size() - 1); return true; } return false; } /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) { Integer listIndex = map.get(val); if (listIndex == null) { return false; } map.put(list.get(list.size() - 1), listIndex); map.remove(val); list.set(listIndex, list.get(list.size() - 1)); list.remove(list.size() - 1); return true; } /** Get a random element from the set. */ public int getRandom() { int randomIndex = random.nextInt(list.size()); return list.get(randomIndex); }} 91算法打卡第六天参考答案","link":"/2020/06/06/380_%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"},{"title":"26. 删除排序数组中的重复项","text":"给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 &nbsp; 示例&nbsp;1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例&nbsp;2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 &nbsp; 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以&ldquo;引用&rdquo;方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { &nbsp; &nbsp; print(nums[i]); } Related Topics数组双指针 以前做过这道题，现在才知道是快慢指针。时间复杂度O(n)，空间复杂度O(1)。 123456789101112131415161718class Solution { public int removeDuplicates(int[] nums) { int len = nums.length; if (len &lt; 2) { return len; } int newIndex = 0; int preNum = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (preNum != nums[i]) { nums[++newIndex] = nums[i]; preNum = nums[i]; } } return newIndex+1; }} 91算法打卡第二十七天参考答案","link":"/2020/06/27/26_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"title":"36. 有效的数独","text":"判断一个&nbsp;9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字&nbsp;1-9&nbsp;在每一行只能出现一次。 数字&nbsp;1-9&nbsp;在每一列只能出现一次。 数字&nbsp;1-9&nbsp;在每一个以粗实线分隔的&nbsp;3x3&nbsp;宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用&nbsp;'.'&nbsp;表示。 示例&nbsp;1: 输入: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: true 示例&nbsp;2: 输入: [ &nbsp; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], &nbsp; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], &nbsp; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], &nbsp; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], &nbsp; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], &nbsp; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], &nbsp; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], &nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], &nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字&nbsp;1-9&nbsp;和字符&nbsp;'.'&nbsp;。 给定数独永远是&nbsp;9x9&nbsp;形式的。 Related Topics哈希表 一次遍历所有的数，并每次都做判断：时间复杂度O(n^2)空间复杂度O(1)。不过貌似时间很长。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public boolean isValidSudoku(char[][] board) { Map&lt;String, Set&lt;Integer&gt;[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[i].length; j++) { String val = String.valueOf(board[i][j]); if (\".\".equalsIgnoreCase(val)) { continue; } Set&lt;Integer&gt;[] sets = map.get(val); Integer area = getArea(i, j); if (sets != null) { if (sets[0].contains(i)) { return false; } if (sets[1].contains(j)) { return false; } if (sets[2].contains(area)) { return false; } sets[0].add(i); sets[1].add(j); sets[2].add(area); continue; } HashSet&lt;Integer&gt; rowSet = new HashSet&lt;&gt;(); HashSet&lt;Integer&gt; columnSet = new HashSet&lt;&gt;(); HashSet&lt;Integer&gt; areaSet = new HashSet&lt;&gt;(); rowSet.add(i); columnSet.add(j); areaSet.add(area); Set&lt;Integer&gt;[] setsArray = new HashSet[]{rowSet, columnSet, areaSet}; map.put(val, setsArray); } } return true;}private Integer getArea(int i, int j) { int x = i / 3 + 1; int y = j / 3; return x + y * 3;}public static void main(String[] args) { Solution solution = new Solution(); char[][] mathLogic = { {'5', '3', '.', '.', '5', '.', '.', '.', '.'}, {'6', '.', '.', '1', '9', '5', '.', '.', '.'}, {'.', '9', '8', '.', '.', '.', '.', '6', '.'}, {'8', '.', '.', '.', '6', '.', '.', '.', '3'}, {'4', '.', '.', '8', '.', '3', '.', '.', '1'}, {'7', '.', '.', '.', '2', '.', '.', '.', '6'}, {'.', '6', '.', '.', '.', '.', '2', '8', '.'}, {'.', '.', '.', '4', '1', '9', '.', '.', '5'}, {'.', '.', '.', '.', '8', '.', '.', '7', '9'} }; boolean validSudoku = solution.isValidSudoku(mathLogic); System.out.println(validSudoku);} 91算法打卡第二十一天参考答案","link":"/2020/06/21/36_%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"},{"title":"447. 回旋镖的数量","text":"给定平面上&nbsp;n 对不同的点，&ldquo;回旋镖&rdquo; 是由点表示的元组&nbsp;(i, j, k)&nbsp;，其中&nbsp;i&nbsp;和&nbsp;j&nbsp;之间的距离和&nbsp;i&nbsp;和&nbsp;k&nbsp;之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设&nbsp;n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 示例: 输入: [[0,0],[1,0],[2,0]] 输出: 2 解释: 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] Related Topics哈希表 看答案才知道怎么解。初步设想的时间复杂度是O(n^3)，想想就放弃了。。。话说求距离的公式，排列组合都忘记了，敢信么。。。如下解法时间复杂度是O(n^2)，空间复杂度是O(n) 1234567891011121314151617181920212223242526public int numberOfBoomerangs(int[][] points) { int sum = 0; if(points==null||points.length&lt;3){ return sum; } Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; points.length; i++) { for (int j = 0; j &lt; points.length; j++) { if (i == j) { continue; } int distance = getDistance(points[i], points[j]); map.put(distance, map.getOrDefault(distance, 0)+1); } for (int val : map.values()) { sum += val * (val - 1); } map.clear(); } return sum;}private int getDistance(int[] i, int[] j) { int x = i[0] - j[0]; int y = i[1] - j[1]; return x*x+y*y;} 91算法打卡第二十天参考答案","link":"/2020/06/20/447_%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"},{"title":"430. 扁平化多级双向链表","text":"多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 &nbsp; 示例 1： 输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 输出：[1,2,3,7,8,11,12,9,10,4,5,6] 解释： 输入的多级列表如下图所示： 扁平化后的链表如下图： 示例 2： 输入：head = [1,2,null,3] 输出：[1,3,2] 解释： 输入的多级列表如下图所示： 1---2---NULL | 3---NULL 示例 3： 输入：head = [] 输出：[] &nbsp; 如何表示测试用例中的多级链表？ 以 示例 1 为例： 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后： [1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。 [1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。 [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] &nbsp; 提示： 节点数目不超过 1000 1 &lt;= Node.val &lt;= 10^5 Related Topics深度优先搜索链表 这道题想了很久哎，最后看了答案，觉得用先序遍历最好理解。主要是多增加一个全局Node，然后先序遍历创建一个新的链表，最后把一开始的全局Node删除即可。 时间复杂度为O(n),空间复杂度O(1) 1234567891011121314151617181920212223242526272829class Solution { Node globalHead = new Node(); Node prev = globalHead; public Node flatten(Node head) { if (head == null) { return null; } preOrderTravel(head); head = globalHead.next; head.prev = null; globalHead.next = null; return head; } private void preOrderTravel(Node head) { if (head == null) { return; } Node child = head.child; Node next = head.next; head.next = head.child = null; prev.next = head; head.prev = prev; prev = head; preOrderTravel(child); preOrderTravel(next); }} 91算法打卡第八天参考答案","link":"/2020/06/08/430_%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"394. 字符串解码","text":"给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像&nbsp;3a&nbsp;或&nbsp;2[4]&nbsp;的输入。 &nbsp; 示例 1： 输入：s = &quot;3[a]2[bc]&quot; 输出：&quot;aaabcbc&quot; 示例 2： 输入：s = &quot;3[a2[c]]&quot; 输出：&quot;accaccacc&quot; 示例 3： 输入：s = &quot;2[abc]3[cd]ef&quot; 输出：&quot;abcabccdcdcdef&quot; 示例 4： 输入：s = &quot;abc3[cd]xyz&quot; 输出：&quot;abccdcdcdxyz&quot; Related Topics栈深度优先搜索 这道题写了超级久，原来用了两个栈，一个队列，然后没法一条路走到黑就放弃了。群里有个人评价博主的方法聪明，从栈里面拿出来计算好再放回去栈里面，一下子点醒我。然后问题迎刃而解。谢谢小伙伴~ 时间复杂度O(n)，空间复杂度O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.regex.Pattern;class Solution { public String decodeString(String s) { String sb = \"\"; Stack&lt;String&gt; strStack = new Stack&lt;&gt;(); char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { String word = \"\"; String repeatCount = \"\"; StringBuilder repeatWordSb = new StringBuilder(); if (chars[i] == ']') { while (!strStack.isEmpty() &amp;&amp; !strStack.peek().equals(\"[\")) { word = strStack.pop().toString() + word; } if (strStack.peek().equals(\"[\")) { strStack.pop(); } while (!strStack.isEmpty() &amp;&amp; isNumber(strStack.peek())) { repeatCount = strStack.pop().toString() + repeatCount; } for (int j = 0; j &lt; Integer.valueOf(repeatCount); j++) { repeatWordSb.append(word); } strStack.push(repeatWordSb.toString()); } else { strStack.push(String.valueOf(chars[i])); } } while (!strStack.isEmpty()) { sb = strStack.pop() + sb; } return sb; } public static boolean isNumber(String str){ Pattern compile = Pattern.compile(\"^[0-9]*$\"); return compile.matcher(str).matches(); }} 加油~ 91算法打卡第四天参考答案","link":"/2020/06/04/394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"title":"513. 找树左下角的值","text":"给定一个二叉树，在树的最后一行找到最左边的值。 示例 1: 输入: 2 / \\ 1 3 输出: 1 &nbsp; 示例 2: 输入: 1 / \\ 2 3 / / \\ 4 5 6 / 7 输出: 7 &nbsp; 注意: 您可以假设树（即给定的根节点）不为 NULL。 Related Topics树深度优先搜索广度优先搜索 嗯，补作业了。昨天看了答案。时间复杂度：O(N)空间复杂度：O(log(N)) 123456789101112131415161718192021public int findBottomLeftValue(TreeNode root) { if (root == null) { return 0; } Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); TreeNode tempRoot = root; nodeQueue.offer(tempRoot); int result = tempRoot.val; while (!nodeQueue.isEmpty()) { TreeNode poll = nodeQueue.poll(); result = poll.val; if (poll.right != null) { nodeQueue.offer(poll.right); } if (poll.left != null) { nodeQueue.offer(poll.left); } } return result;} 91算法打卡第十六天参考答案","link":"/2020/06/17/513_%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"},{"title":"547. 朋友圈","text":"班上有&nbsp;N&nbsp;名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B&nbsp;的朋友，B 是 C&nbsp;的朋友，那么我们可以认为 A 也是 C&nbsp;的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个&nbsp;N * N&nbsp;的矩阵&nbsp;M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 输入: [[1,1,0], [1,1,0], [0,0,1]] 输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。 第2个学生自己在一个朋友圈。所以返回2。 示例 2: 输入: [[1,1,0], [1,1,1], [0,1,1]] 输出: 1 说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 Related Topics深度优先搜索并查集 感谢【小漾童鞋找的资料】，然后我就看懂了~ 时间复杂度 O(α(n))，空间复杂度O(n)，n代表人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution { public int findCircleNum(int[][] M) { UnionFindSet unionFindSet = new UnionFindSet(M.length); for (int i = 0; i &lt; M.length; i++) { for (int j = 0; j &lt; i; j++) { if (M[i][j] == 1) { unionFindSet.unionSet(i, j); } } } return unionFindSet.getSumOfUnions(); } }class UnionFindSet { private int[] parents; private int[] ranks; private int sumOfUnions; public UnionFindSet(int num) { this.parents = new int[num]; for (int i = 0; i &lt; this.parents.length; i++) { parents[i] = i; } this.ranks = new int[num]; this.sumOfUnions = num; } private int findSet(int x) { if (x != parents[x]) { parents[x] = findSet(parents[x]); } return parents[x]; } public void unionSet(int x, int y) { int rootX = findSet(x); int rootY = findSet(y); if (rootX == rootY) { return; } if (ranks[rootX] &gt; ranks[rootY]) { parents[rootY] = rootX; } else { parents[rootX] = rootY; if (ranks[rootX] == ranks[rootY]) { ranks[rootY]++; } } this.sumOfUnions--; } public int getSumOfUnions() { return sumOfUnions; } public void setSumOfUnions(int sumOfUnions) { this.sumOfUnions = sumOfUnions; }} 91算法打卡第四十四天参考答案","link":"/2020/07/14/547_%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"title":"581. 最短无序连续子数组","text":"给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在&nbsp;[1, 10,000]。 输入的数组可能包含重复元素&nbsp;，所以升序的意思是&lt;=。 Related Topics数组 暴力思路：这是我原先的思路，只顾着找右边界，每次找到符合条件的右边界，就暴力找左边界。时间复杂度O(n^2)空间复杂度O(1) 123456789101112131415161718192021public int findUnsortedSubarray(int[] nums) { int tempMax = nums[0]; int start = Integer.MAX_VALUE; int end = -1; for (int i = 1; i &lt; nums.length; i++) { if (tempMax &gt; nums[i]) { for (int j = 0; j &lt; nums.length; j++) { if (nums[j] &gt; nums[i]) { start = Math.min(j, start); } } end = i; } else { tempMax = nums[i]; } } if (end != -1) { return end - start + 1; } return 0;} 优化思路：这个思路是看群友的，用的双指针，找右边界的同时，找左边界。时间复杂度O(n)空间复杂度O(1) 123456789101112131415161718192021public int findUnsortedSubarray(int[] nums) { int max = nums[0]; int min = nums[nums.length - 1]; int start = 0; int end = -1; for (int i = 0; i &lt; nums.length; i++) { int left = i; int right = nums.length - i - 1; if (max &gt; nums[i]) { end = left; } else { max = nums[left]; } if (min &lt; nums[right]) { start = right; } else { min = nums[right]; } } return end &gt; 0 ? end - start + 1 : 0;} 91算法打卡第三十四天参考答案","link":"/2020/07/04/581_%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"62. 不同路径","text":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ &nbsp; 示例&nbsp;1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右 示例&nbsp;2: 输入: m = 7, n = 3 输出: 28 &nbsp; 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9 Related Topics数组动态规划 第一种方法超时：时间复杂度O(2^max(m,n))空间复杂度O(max(m,n)),递归的最大深度。 123456public int uniquePaths(int m, int n) { if (m == 1 || n == 1) { return 1; } return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);} 以下方法是看了群友的思路：第二种方法： 时间复杂度O(m*n) 空间复杂度O(m*n) 1234567891011121314public int uniquePaths(int m, int n) { int[][] array= new int[m+1][n+1]; array[1][1] = 1; for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (i == 1 &amp;&amp; j == 1) { continue; } array[i][j] = array[i][j - 1] + array[i - 1][j]; } } return array[m][n];} 第三种方法，空间优化： 时间复杂度O(m*n) 空间复杂度O(n) 123456789101112public int uniquePaths(int m, int n) { int[] last= new int[n+1]; last[1] = 1; for (int i = 1; i &lt;= m; i++) { int[] cur= new int[n+1]; for (int j = 1; j &lt;= n; j++) { cur[j] = last[j] + cur[j - 1]; } last=cur; } return last[n];} 91算法打卡第三十六天参考答案","link":"/2020/07/06/62_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"75. 颜色分类","text":"给定一个包含红色、白色和蓝色，一共&nbsp;n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、&nbsp;1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ Related Topics排序数组双指针 不知道这样符合群主要求不？过了leetcode的。不过觉得确实不好。这个方法是早上看了一个公众号借鉴的，不过看了其他同学的答案，又回过头看了公众号，自己应该是没有领悟到该方法的精髓。 该方法是假设有三个挡板，i , j ,k 。[0,i) 存1，[i,j) 存2，(k,nums.length -1] 存3 , [j,k] 为未排序区 //伪代码如下 while (j&lt;=k){ //穷尽各种可能性，毕竟只有三种数字。}时间复杂度 O(n)，空间复杂度O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public void sortColors(int[] nums) { int i = 0 ; int j = 0 ; int k = nums.length -1 ; while (j&lt;=k){ if(nums[i]==0){ if(i==j){ j++; } i++; continue; } if(nums[j]==1){ j++; continue; } if(nums[k]==2){ k--; continue; } if(nums[i]==1&amp;&amp;nums[j]==0){ nums[i]=0; nums[j]=1; i++; j++; continue; } if(nums[i]==2&amp;&amp;nums[k]==0){ nums[i]=0; nums[k]=2; if(i==j){ j++; } i++; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==0){ nums[j]=0; nums[k]=2; k--; continue; } if(nums[j]==2&amp;&amp;nums[k]==1){ nums[j]=1; nums[k]=2; j++; k--; continue; } } }} 改进： 时间复杂度 O(n)，空间复杂度O(1) 1234567891011121314151617181920212223242526272829class Solution { private void swap(int[] nums,int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } public void sortColors(int[] nums) { int i = 0 ; int cur = 0; int k = nums.length -1 ; while ( i &lt;= k &amp;&amp; cur &lt;= k ){ if(nums[cur]==0){ swap(nums,cur,i); i++; cur++; }else if(nums[cur]==1){ cur++; }else if(nums[cur]==2){ swap(nums,cur,k); k--; //cur++; 无法确定换回来的数是什么，所以不能加这个。 } } }} 91算法打卡第二天参考答案","link":"/2020/06/02/75_%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"},{"title":"645. 错误的集合","text":"集合 S 包含从1到&nbsp;n&nbsp;的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。 给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1: 输入: nums = [1,2,2,4] 输出: [2,3] 注意: 给定数组的长度范围是&nbsp;[2, 10000]。 给定的数组是无序的。 Related Topics哈希表数学 有考虑异或，但没想出来。时间复杂度O(n)，空间复杂度O(n) 12345678910111213141516171819202122232425public int[] findErrorNums(int[] nums) { int length = nums.length; int doubleNum = 0; int lostNum = 0; BitSet bitSet = new BitSet(length); for (int i = 0; i &lt; length; i++) { if (bitSet.get(nums[i])) { doubleNum = nums[i]; } else { bitSet.set(nums[i],true); } } for (int i = 1; i &lt; bitSet.length(); i++) { if (!bitSet.get(i)) { lostNum = i; break; } } if (lostNum == 0) { lostNum=length; } return new int[]{doubleNum, lostNum};} 91算法打卡第二十二天参考答案","link":"/2020/06/22/645_%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/"},{"title":"677. 键值映射","text":"实现一个 MapSum 类里的两个方法，insert&nbsp;和&nbsp;sum。 对于方法&nbsp;insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。 对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。 示例 1: 输入: insert(&quot;apple&quot;, 3), 输出: Null 输入: sum(&quot;ap&quot;), 输出: 3 输入: insert(&quot;app&quot;, 2), 输出: Null 输入: sum(&quot;ap&quot;), 输出: 5 Related Topics字典树 map空间复杂度O(n)，insert 时间复杂度O(1),sum 时间辅助度O(n) 12345678910111213141516171819202122private Map&lt;String,Integer&gt; map;/** Initialize your data structure here. */public MapSum() { map = new HashMap&lt;&gt;();}public void insert(String key, int val) { map.put(key, val);}public int sum(String prefix) { int sum = 0; Iterator&lt;String&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { String next = iterator.next(); if (next.startsWith(prefix)) { sum += map.get(next); } } return sum;} Trie + map空间复杂度O(n)，insert 时间复杂度O(n), n为 单词的长度sum 时间辅助度O(n+m)， n为 单词的长度 , m 为以单词最后的字母为root的所有节点数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class MapSum { Trie trie; /** * Initialize your data structure here. */ public MapSum() { trie = new Trie(); } public void insert(String key, int val) { if (key == null) { return; } String[] singleWord = key.split(\"\"); Trie curTrie = this.trie; for (int i = 0; i &lt; singleWord.length; i++) { Map&lt;String, Trie&gt; next = curTrie.next; if (next == null) { next = new HashMap&lt;&gt;(); } if (!next.containsKey(singleWord[i])) { next.put(singleWord[i], new Trie()); } curTrie.next = next; curTrie = next.get(singleWord[i]); } curTrie.end = true; curTrie.val = val; } public int sum(String prefix) { if (prefix == null) { return 0; } String[] singleWord = prefix.split(\"\"); Trie curTrie = this.trie; for (int i = 0; i &lt; singleWord.length; i++) { Map&lt;String, Trie&gt; next = curTrie.next; if (next == null) { return 0; } if (!next.containsKey(singleWord[i])) { return 0; } curTrie = next.get(singleWord[i]); } int sumOfVal = Trie.getSumOfVal(curTrie); return sumOfVal; }}class Trie { Map&lt;String, Trie&gt; next; boolean end; int val; public Trie() { this.next = new HashMap&lt;&gt;(); this.end = false; this.val = 0; } public static int getSumOfVal(Trie trie) { if (trie == null) { return 0; } int sum = 0; Map&lt;String, Trie&gt; next = trie.next; if (next != null) { Iterator&lt;String&gt; iterator = next.keySet().iterator(); while (iterator.hasNext()) { Trie childTrie = next.get(iterator.next()); int sumOfVal = getSumOfVal(childTrie); sum += sumOfVal; } } sum += trie.val; return sum; }} Trie空间复杂度O(n)，insert 时间复杂度O(n), n为 单词的长度sum 时间辅助度O(n+m)， n为 单词的长度 , m 为以单词最后的字母为root的所有节点数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class MapSum { Trie trie; /** * Initialize your data structure here. */ public MapSum() { trie = new Trie(); } public void insert(String key, int val) { if (key == null) { return; } char[] chars = key.toCharArray(); Trie curTrie = this.trie; for (int i = 0; i &lt; chars.length; i++) { int index = chars[i] - 'a'; if (curTrie.next[index] == null) { curTrie.next[index] = new Trie(); } curTrie=curTrie.next[index]; } curTrie.end = true; curTrie.val = val; } public int sum(String prefix) { if (prefix == null) { return 0; } char[] chars = prefix.toCharArray(); Trie curTrie = this.trie; for (int i = 0; i &lt; chars.length; i++) { int index = chars[i] - 'a'; if (curTrie.next[index] == null) { return 0; } curTrie= curTrie.next[index]; } int sumOfVal = Trie.getSumOfVal(curTrie); return sumOfVal; }}class Trie { Trie[] next; boolean end; int val; public Trie() { this.next = new Trie[26]; this.end = false; this.val = 0; } public static int getSumOfVal(Trie trie) { if (trie == null) { return 0; } int sum = 0; Trie[] next = trie.next; if (next != null) { for (int i = 0; i &lt; next.length; i++) { Trie curTrie = next[i]; int sumOfVal = getSumOfVal(curTrie); sum += sumOfVal; } } sum += trie.val; return sum; }} 91算法打卡第四十二天参考答案","link":"/2020/07/12/677_%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/"},{"title":"78. 子集","text":"给定一组不含重复元素的整数数组&nbsp;nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], &nbsp; [1], &nbsp; [2], &nbsp; [1,2,3], &nbsp; [1,3], &nbsp; [2,3], &nbsp; [1,2], &nbsp; [] ] Related Topics位运算数组回溯算法 暴力解法，没想到执行时间能超过那么多人。伪代码思路如下： 创建全局的list，用于存所有的组合。 首先在list 放入一个空数组 遍历整个nums： 每遍历到一个num，就把list的所有的组合拿出来，复制一份，然后每个复制的组合再加上这个num，存入list中。 返回list 时间复杂度 O(2^n - 1)空间复杂度 O(2^(n-1)) 12345678910111213141516List&lt;List&lt;Integer&gt;&gt; list = new ArrayList();public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;Integer&gt; nulList = new ArrayList&lt;&gt;(); list.add(nulList); for (int i = 0; i &lt; nums.length; i++) { List&lt;List&lt;Integer&gt;&gt; tempList = new ArrayList(); for (List&lt;Integer&gt; subList : list) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(subList); integers.add(nums[i]); tempList.add(integers); } list.addAll(tempList); } return list;} 91算法打卡第三十五天参考答案","link":"/2020/07/05/78_%E5%AD%90%E9%9B%86/"},{"title":"924. 尽量减少恶意软件的传播","text":"在节点网络中，只有当 graph[i][j] = 1&nbsp;时，每个节点&nbsp;i&nbsp;能够直接连接到另一个节点 j。 一些节点&nbsp;initial&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)，&nbsp;则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。 &nbsp; 示例 1： 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] 输出：0 示例 2： 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] 输出：0 示例 3： 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] 输出：1 &nbsp; 提示： 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] == 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length Related Topics深度优先搜索并查集 借鉴群友思路写出来的~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Solution { public int minMalwareSpread(int[][] graph, int[] initial) { if (graph == null || initial == null || graph.length == 0 || initial.length == 0) { return 0; } UnionFindSet unionFindSet = new UnionFindSet(graph.length); Map&lt;Integer, Integer&gt; rootSizeMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; graph.length; i++) { for (int j = 0; j &lt; i; j++) { if (graph[i][j] == 1) { unionFindSet.unionSet(i, j); } } } for (int i = 0; i &lt; initial.length; i++) { int root = unionFindSet.findSet(initial[i]); rootSizeMap.put(root, rootSizeMap.getOrDefault(root, 0) + 1); } int result = initial[0]; int malwareSpread = Integer.MIN_VALUE; for (int i = 0; i &lt; initial.length; i++) { int root = unionFindSet.findSet(initial[i]); if (rootSizeMap.get(root) &gt; 1) { if (malwareSpread == Integer.MIN_VALUE) { //the initial array exist more than one element in the same set Of UnionFindSet, and now have not find the single element in the independent set of UnionFindSet. compare the index of element , and update result = Math.min(result, initial[i]); } continue; } if (unionFindSet.getSizeOfSet(root) &gt; malwareSpread) { //find the larger set ,update the index malwareSpread = unionFindSet.getSizeOfSet(root); result = initial[i]; continue; } if (unionFindSet.getSizeOfSet(root) == malwareSpread) { //the size of set now equal , compare the index and get the smaller result = Math.min(result, initial[i]); } } return result; } public static void main(String[] args) { Solution solution = new Solution(); int[][] graph = {{1,0,0,0,1,0,0,0},{0,1,1,0,0,1,0,0},{0,1,1,0,1,0,0,0},{0,0,0,1,1,0,0,0},{1,0,1,1,1,0,0,1},{0,1,0,0,0,1,0,0},{0,0,0,0,0,0,1,1},{0,0,0,0,1,0,1,1}}; int[] initial = {7,2}; int i = solution.minMalwareSpread(graph, initial); System.out.println(i); }}class UnionFindSet { private int[] parents; private int[] ranks; private int sumOfSet; private int[] sizeOfSet; public UnionFindSet(int num) { this.parents = new int[num]; this.ranks = new int[num]; this.sumOfSet = num; this.sizeOfSet = new int[num]; for (int i = 0; i &lt; parents.length; i++) { parents[i] = i; } for (int i = 0; i &lt; sizeOfSet.length; i++) { sizeOfSet[i] = 1; } for (int i = 0; i &lt; ranks.length; i++) { ranks[i] = i; } } public int findSet(int x) { if (x != parents[x]) { parents[x] = findSet(parents[x]); } return parents[x]; } public void unionSet(int x, int y) { int rootX = findSet(x); int rootY = findSet(y); if (rootX == rootY) { return; } if (ranks[rootX] &gt; ranks[rootY]) { parents[rootY] = rootX; sizeOfSet[rootX] += sizeOfSet[rootY]; } else { parents[rootX] = rootY; sizeOfSet[rootY] += sizeOfSet[rootX]; if (ranks[rootX] == ranks[rootY]) { ranks[rootY]++; } } sumOfSet--; } public int getSumOfSet() { return sumOfSet; } public int getSizeOfSet(int x) { return sizeOfSet[x]; }} 91算法打卡第四十五天参考答案","link":"/2020/07/15/924_%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/"},{"title":"875. 爱吃香蕉的珂珂","text":"珂珂喜欢吃香蕉。这里有&nbsp;N&nbsp;堆香蕉，第 i 堆中有&nbsp;piles[i]&nbsp;根香蕉。警卫已经离开了，将在&nbsp;H&nbsp;小时后回来。 珂珂可以决定她吃香蕉的速度&nbsp;K&nbsp;（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp; 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。 &nbsp; 示例 1： 输入: piles = [3,6,7,11], H = 8 输出: 4 示例&nbsp;2： 输入: piles = [30,11,23,4,20], H = 5 输出: 30 示例&nbsp;3： 输入: piles = [30,11,23,4,20], H = 6 输出: 23 &nbsp; 提示： 1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9 Related Topics二分查找 用二分法。直到max&gt;min这个条件不符合，结束循环。时间复杂度：O(nlogN)，N为一开始min-max的范围，n为piles的个数空间复杂度：O(1) 123456789101112131415161718192021222324252627282930class Solution { public int minEatingSpeed(int[] piles, int H) { int max = 0; int min = 0; double sum = 0; for (int i = 0; i &lt; piles.length; i++) { max = Math.max(piles[i], max); sum += piles[i]; } min = (int) Math.ceil(sum / H); while (min &lt; max) { int mid = (int)Math.ceil((min + max) / 2); int needHours = 0; for (int i = 0; i &lt; piles.length; i++) { needHours+=(int) Math.ceil((double)piles[i]/mid); } if (needHours &gt; H) { if (min == mid) { min = mid = mid + 1; }else{ min = mid; } }else{ max = mid; } } return min; }} 91算法打卡第二十六天参考答案","link":"/2020/06/26/875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"},{"title":"66. 加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 123456789101112131415161718192021class Solution { public int[] plusOne(int[] digits) { for(int i = digits.length-1;i&gt;=0;i--){ if(digits[i]+1==10){ digits[i]=0; }else{ digits[i]+=1; break; } } //the old digits is 9 or 99 and so on if(digits[0]==0){ int[] newDigits=new int[digits.length+1]; newDigits[0]=1; return newDigits; } return digits; }} 以前有做过，当回顾~ 第一天打卡(^__^) 91算法打卡第一天参考答案","link":"/2020/06/01/66_%E5%8A%A0%E4%B8%80/"},{"title":"Tomcat8.5.50源码环境搭建","text":"学源码，当然是要先把环境搭建好咯。下面跟着杰哥一起搭建环境吧~ 1. 首先到tomcat官网下载 src 和 部署包。 2. 下载后解压src 包和 bin包。3. 在src包中添加pom.xml文件，引入需要的依赖。 在pom.xml添加如下配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt; &lt;name&gt;Tomcat8.5&lt;/name&gt; &lt;version&gt;8.5&lt;/version&gt; &lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--Tomcat是java开发的，封装了很多新功能，它需要依赖一些基础的jar包--&gt; &lt;dependencies&gt; &lt;!--远程过程调用工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--soap协议处理工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt; &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--解析webservice的wsdl文件工具--&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eclipse Java编译器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt; &lt;artifactId&gt;ecj&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--ant管理工具--&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--easymock辅助单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 启动idea，导入该项目，并将它转成maven工程。 5. tomcat是一个java se工程，在config中配置启动类： 其中，vm option的具体配置如下： 1234-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties 6. 保存好。如果现在启动会因为jsp没有解析报错，所以需要添加jsp 的解析，如下：在ContextConfig的类中configureStart 方法添加 初始化jsp解析引擎： 1234//位置：package org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:788) //初始化jsp解析引擎-japser context.addServletContainerInitializer(new JasperInitializer(), null); 7. 启动tomcat ,可以访问到tomcat的页面了。控制台乱码解决杰哥总结了3种方法，读者按需配置： 设置语言环境： 在如上的第6步的vm option 添加如下配置，将环境改成英文环境，避免乱码: 1234567-Dcatalina.home=E:/Item/apache-tomcat-8.5.50-src/source-Dcatalina.base=E:/Item/apache-tomcat-8.5.50-src/source-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=E:/Item/apache-tomcat-8.5.50-src/source/conf/logging.properties-Dfile.encoding=UTF-8-Duser.language=en-Duser.region=US 修改如下两个地方的编码： pom 的jdk 修改成11，并做好jdk11 的环境安装配置(未尝试) 1234567891011121314151617181920212223&lt;build&gt; &lt;!--指定源目录--&gt; &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt; &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--引入编译插件，指定编译级别和编码--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","link":"/2020/05/13/Tomcat8.5.50%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表","text":"反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ Related Topics链表 方法1——迭代时间复杂度O(n)，空间复杂度O(1) 1234567891011121314public ListNode reverseList(ListNode head) { ListNode temp = null; if (head == null) { return null; } while (head.next != null) { ListNode tempHead = head; head = head.next; tempHead.next = temp; temp = tempHead; } head.next = temp; return head;} 方法2——递归时间复杂度O(n)，空间复杂度O(n) 12345678910111213141516171819202122ListNode last = null;public ListNode reverseList(ListNode head) { reverse(head); return last;}void reverse(ListNode head) { if (head == null) { return; } if (head.next == null) { last = head; return; } ListNode tempHead = head.next; head.next = null; reverse(tempHead); tempHead.next = head; } 92. 反转链表 II反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 &le;&nbsp;m&nbsp;&le;&nbsp;n&nbsp;&le; 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL Related Topics链表 迭代 思路：记录位置m-1的listnode A和 n+1 的 listnode B , 翻转 m-n 的子链表，得到翻转后的子链表的 head listnode C 和 tail listnode D ，然后 A -&gt;C -&gt; D -&gt;B 时间复杂度O(n)，空间复杂度O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) { return null; } int index = 1; ListNode top = head; //reverse children listnode ListNode temp = null; //disreverse listnode left index ListNode left = null; //disreverse listnode right index ListNode right = null; //reverse children listnode right index ListNode innerRight = null; while (head != null) { if (index == m - 1 &amp;&amp; m &gt; 1) { left = head; } if (index == n + 1) { right = head; break; } ListNode next = head.next; if (index &gt;= m &amp;&amp; index &lt;= n) { if (index == m) { innerRight = head; } head.next = temp; temp = head; } head = next; index++; } if (left != null) { left.next = temp; } if (innerRight != null) { innerRight.next = right; } if (m == 1) { return temp; } return top;} 25. K 个一组翻转链表给你一个链表，每&nbsp;k&nbsp;个节点一组进行翻转，请你返回翻转后的链表。 k&nbsp;是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是&nbsp;k&nbsp;的整数倍，那么请将最后剩余的节点保持原有顺序。 &nbsp; 示例： 给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当&nbsp;k&nbsp;= 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当&nbsp;k&nbsp;= 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 &nbsp; 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 Related Topics链表 迭代 思路：每k个一组翻转，分为偶数组和奇数组，当偶数组时，就把前面的奇数组的最后一个next 改成 当前偶数组的 head，当奇数组时，就把前面的偶数组的最后一个next 改成 当前奇数组的 head。 (reverseCount &amp; 1) == 0 用来判断是否为偶数，方法来自小灰算法。 时间复杂度O(n)，空间复杂度O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475ListNode oddReverseChildHead = null;ListNode oddReverseChildTail = null;ListNode evenReverseChildHead = null;ListNode evenReverseChildTail = null;int reverseCount = 1;public ListNode reverseKGroup(ListNode head, int k) { int index = 1; if (k == 1) { return head; } ListNode childHead = null; ListNode top = null; boolean firstFlag = true; while (head != null) { ListNode tempHead = head.next; if (index % k == 0) { head.next = null; reverseChild(childHead); if (firstFlag) { top = head; firstFlag = false; } if ((reverseCount &amp; 1) == 0) { //is even oddReverseChildTail.next = evenReverseChildHead; oddReverseChildHead = null; oddReverseChildTail = null; } else { if (evenReverseChildHead != null) { // is old evenReverseChildTail.next = oddReverseChildHead; evenReverseChildHead = null; evenReverseChildTail = null; } } childHead = null; reverseCount++; } if (index % k == 1) { childHead = head; } head = tempHead; index++; } if ((reverseCount &amp; 1) == 0) { // is even oddReverseChildTail.next = childHead; } else { // is odd evenReverseChildTail.next = childHead; } return top;}private void reverseChild(ListNode head) { ListNode top = null; ListNode tail = head; while (head != null) { ListNode tempHead = head.next; head.next = top; top = head; head = tempHead; } if ((reverseCount &amp; 1) == 0) { // is even evenReverseChildHead = top; evenReverseChildTail = tail; } else { //is odd oddReverseChildHead = top; oddReverseChildTail = tail; }} 91算法打卡第三十八天参考答案","link":"/2020/07/08/92_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"},{"title":"依赖倒转原则","text":"基本介绍 依赖倒转原则(Dependence Inversion Principle)是指： 细节应该依赖抽象 依赖倒转(倒置)的本质是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 反例：123456789101112131415161718192021public class Sms { public String getMsg(){ return \"hello world\"; }}public class Mobile { public void receiveMsg(Sms sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); Sms sms = new Sms(); mobile.receiveMsg(sms); }} 如上Mobile类的receiveMsg方法参数是具体的对象Sms，如果以后还需要接收其他类型的数据，比如微信等，需要重新写方法，非常不利于扩展，改动大。 正例：改成面向接口对象即可。 123456789101112131415161718192021222324252627282930313233343536public interface IMsg { String getMsg();}public class Sms implements IMsg{ public String getMsg(){ return \"hello world\"; }}public class WeChatMsg implements IMsg{ @Override public String getMsg() { return \"WeChat is ok\"; }}public class Mobile { public void receiveMsg(IMsg sms){ System.out.println(sms.getMsg()); }}public class Main { public static void main(String[] args) { Mobile mobile = new Mobile(); IMsg sms = new Sms(); mobile.receiveMsg(sms); IMsg weChatMsg = new WeChatMsg(); mobile.receiveMsg(weChatMsg); }} 依赖关系传递的三种方式和应用案例 接口传递 12345678910111213141516171819202122232425262728293031public interface Run { void run();}public interface Fly { void flyHigh(Run run);}public class QuickRun implements Run{ @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly{ @Override public void flyHigh(Run run) { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(); duckFly.flyHigh(quickRun); }} 构造方法传递 1234567891011121314151617181920212223242526272829303132333435363738public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; public DuckFly(Run run) { this.run = run; } @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); Fly duckFly = new DuckFly(quickRun); duckFly.flyHigh(); }} setter 方法传递(较少使用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Run { void run();}public interface Fly { void flyHigh();}public class QuickRun implements Run { @Override public void run() { System.out.println(\"飞奔。。。\"); }}public class DuckFly implements Fly { Run run; @Override public void flyHigh() { run.run(); System.out.println(\"飞不高\"); } public Run getRun() { return run; } public void setRun(Run run) { this.run = run; }}public class Main { public static void main(String[] args) { Run quickRun = new QuickRun(); DuckFly duckFly = new DuckFly(); duckFly.setRun(quickRun); duckFly.flyHigh(); }} 依赖倒转原则的注意事项和细节 低层模块最好有抽象类或者接口，这样程序稳定性好。解释说明：每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。 变量的声明尽量是抽象类或者接口，这样变量引用和实际对象间有了一个缓冲，利于程序的扩展和优化比如我们方法参数常用List 而不是ArrayList，这样当我们需要LinkedList的时候，方法不需要改变什么就可以直接使用了。 继承时要遵循里氏替换原则 题外话： 应用了工厂方法之后，你会注意到，高层模块（也就是该文提到的PizzaStore）和 低层模块（也就是该文提到的各种具体Pizza）都依赖了Pizza 抽象。想要遵循依赖倒转原则，工厂方法并非是唯一的技巧，但是却是最有威力的技巧之一。 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns https://mp.weixin.qq.com/s/vo-44mor5y8Ck1Rs2jMPgw 参考资源: 韩顺平 《图解Java设计模式》 《Head First设计模式》","link":"/2020/05/20/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/"},{"title":"原型模式","text":"引文克隆猴问题： 现有一只克隆猴，姓名：Sun,年龄：4，颜色：White。请克隆2只Sun，属性一模一样。 传统方式解决克隆问题 思路分析（图解） 代码演示 1234567891011121314151617181920212223public class Money { private String name; private Integer age; private String color; public Money(String name, Integer age, String color) { this.name = name; this.age = age; this.color = color; } //省略 get set 方法}public class Client { public static void main(String[] args) { Money money = new Money(\"sun\", 4, \"White\"); //clone Money money1 = new Money(money.getName(), money.getAge(), money.getColor()); Money money2 = new Money(money.getName(), money.getAge(), money.getColor()); }} 传统方式的优缺点 优点是比较好理解，简单易操作。 缺点是在创建新对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。 总是需要重新初始化对象，而不是动态地获取对象运行时的状态，不够灵活。比如 Money类里面有新的属性height，但是并没有放入构造方法参数中。这时候用构造方法初始化就拿不到这个值了。 改进思路在Java中提供了clone()方法来实现对象的克隆，这使得实现原型模式变得简单许多，只是需要相应的Java 类必须实现一个Cloneable接口。 基本介绍 原型模式（Prototype模式）是指 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。 原型模式是一种创建型设计模式，允许一个对象再创建另外一个定制的对象，无需知道如何创建的细节。 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实施创建，即对象.clone() 形象的理解：孙大圣拔出猴毛，变出其他孙大圣 参考资源: 韩顺平 《图解Java设计模式》 《Java与模式》 《Head first 设计模式》","link":"/2020/07/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"单一职责原则","text":"基本介绍： 对类来说，即一个类只负责一项职责。如类A 负责两个不同职责： 职责1，职责2。当职责1 需求变更而改变A时，可能会造成职责2执行错误，所以需要将类A的粒度分解成A1，A2 反例：12345678910111213141516171819202122232425262728public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路上面跑\"); }}public class SingleResponsibility1 { //方式1 的run方法违反单一职责原则 //解决的方案非常简单，根据交通工具运行方式不同，分解不同类即可。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.run(\"飞机\"); //wrong }} 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class RoadVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在公路运行\"); }}public class AirVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在空中运行\"); }}public class WaterVehicle { public void run(String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility2 { //方式2 遵守了单一职责，但是这样的改动很大，即将类分解，同时修改客户端。 public static void main(String[] args) { RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run(\"摩托车\"); roadVehicle.run(\"汽车\"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run(\"飞机\"); WaterVehicle waterVehicle = new WaterVehicle(); waterVehicle.run(\"潜水艇\"); }} 改进：12345678910111213141516171819202122232425262728293031323334353637383940public class Vehicle { public void run (String vehicle){ System.out.println(vehicle+\"在公路运行\"); } public void runAir (String vehicle){ System.out.println(vehicle+\"在天空运行\"); } public void runWater (String vehicle){ System.out.println(vehicle+\"在水中运行\"); }}public class SingleResponsibility3 { //方式3 只是增加了方法。虽然没有类这个级别上遵守单一职责原则，但是在方法的级别上，仍然准备单一职责原则的。 public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\"摩托车\"); vehicle.run(\"汽车\"); vehicle.runAir(\"飞机\"); }} 注意细节事项和细节： 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则的；只有类中方法数量足够少，才可以在方法级别保持单一职责原则。 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/05/15/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"},{"title":"合成复用原则","text":"基本介绍原则是尽量使用合成/聚合的方式，而不是使用继承 设计原则核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对实现编程 尽可能实现松耦合设计 合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 下面以摩托车分类管理程序为例来介绍合成复用原则的应用。 分析：摩托车按“动力源”划分可分为汽油摩托车、电动摩托车等；按“颜色”划分可分为白色摩托车、黑色摩托车和红色摩托车等。如果同时考虑这两种分类，其组合就很多。如下所示是用继承关系实现的摩托车分类的类图。 我们可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下 所示。 总结结合前几节的内容，我们一共介绍了 7种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则。 这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/06/07/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/"},{"title":"开闭原则","text":"基本介绍 开闭原则（Open Closed Principle） 是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。 就比如开发新需求，你大可以扩展代码，但是你要确保原先的调用者不用发生一丁点变化。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 编程中使用设计模式的目的就是为了遵循开闭原则。 反例： 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class Shape { int shapeType;}public class Rectangle extends Shape{ public Rectangle() { super.shapeType=1; }}public class Circle extends Shape{ public Circle() { super.shapeType=2; }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ if (s.shapeType==1) { drawRectangle(s); }else if (s.shapeType==2){ drawCircle(s); } } private void drawCircle(Shape s) { System.out.println(\"绘制圆形\"); } private void drawRectangle(Shape s) { System.out.println(\"绘制矩形\"); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如上设计，当我们要绘制一个新的图形，比如三角形，我们一定要动到GraphicEditor这个使用方的类，这样就违反了开闭原则了。 12345678910111213141516171819202122public class Triangle extends Shape{ public Triangle() { super.shapeType=3; }}public class GraphicEditor { public void drawShape(Shape s){ //省略重复代码... else if (s.shapeType==2){ drawTriangle(s); } } private void drawTriangle(Shape s) { System.out.println(\"绘制三角形\"); }} 正例：思路： 我们在shape类中提供一个抽象方法，让子类去实现即可。这样当我们有新的图形类继承的时候，实现draw方法即可，也避免修改使用方的代码，从而满足开闭原则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Shape { int shapeType; abstract void drawShape();}public class Rectangle extends Shape { public Rectangle() { super.shapeType=1; } @Override void drawShape() { System.out.println(\"绘制矩形\"); }}public class Circle extends Shape { public Circle() { super.shapeType=2; } @Override void drawShape() { System.out.println(\"绘制圆形\"); }}//这是一个用于绘图的类【使用方】public class GraphicEditor { public void drawShape(Shape s){ s.drawShape(); }}public class Main { public static void main(String[] args) { GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); }} 如 依赖倒转原则的正例，也是符合开闭原则的范例，可以回顾下~ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/05/23/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"},{"title":"数组_53最大子序和","text":"给定一个整数数组 nums&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释:&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 Related Topics数组分治算法动态规划 这道题花了两个小时。各种考虑不周。其实三天前就看了答案的，知道有负收益这回事，但是真到了码代码就出错了。 1234567891011121314151617181920212223242526class Solution { public int maxSubArray(int[] nums) { //记录目前出现的最大的和 int max = nums[0]; //连续求和 int sum = 0; //一开始就赋值nums[0]，并循环从下标为1 的开始，导致漏了这种情况 [-1,2,3],无经验的表现。 for (int i = 0; i &lt; nums.length; i++) { sum+=nums[i]; //一旦sum小于等于0，就是无收益，放弃这个子数组，准备重新取值 if (sum &lt;= 0) { if(nums[i]&gt;0){ //nums[i]还是正收益，取该值 sum=nums[i]; }else { //nums[i]&lt;=0,从下个开始取 sum=0; } max = Math.max(nums[i], max); }else { max = Math.max(sum, max); } } return max; }} 看题解，思路更易懂些： 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for(int num: nums) { if(sum &gt; 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }}","link":"/2020/05/20/%E6%95%B0%E7%BB%84_53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"},{"title":"数组_88合并两个有序数组","text":"给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。 &nbsp; 说明: 初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。 你可以假设&nbsp;nums1&nbsp;有足够的空间（空间大小大于或等于&nbsp;m + n）来保存 nums2 中的元素。 &nbsp; 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出:&nbsp;[1,2,2,3,5,6] Related Topics数组双指针 这道题还是蛮简单的，只要注意参数m 和 n 就好。 12345678910111213141516171819202122232425262728293031323334class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int p=m+n; while(m&gt;0||n&gt;0){ p--; //exist m and n ,compare if(m&gt;0&amp;&amp;n&gt;0){ if(nums1[m-1]&gt;nums2[n-1]){ nums1[p] = nums1[m - 1]; m--; }else{ nums1[p] = nums2[n - 1]; n--; } continue; } //only exits m,move m if(m&gt;0){ nums1[p] = nums1[m - 1]; m--; continue; } //only exits n,move n if(n&gt;0){ nums1[p] = nums2[n - 1]; n--; continue; } } }}","link":"/2020/05/23/%E6%95%B0%E7%BB%84_88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"title":"接口隔离原则","text":"基本介绍 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖应该建立在最小的接口上。 改造前：改造前，如下UML图所示 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public interface Interface1 {​ void operation1();​ void operation2();​ void operation3();​ void operation4();​ void operation5();}public class B implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"B 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"B 实现了operation5\");​ }}public class D implements Interface1 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"D 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"D 实现了operation3\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend2(Interface1 inteface1){​ inteface1.operation2();​ }​ public void depend3(Interface1 inteface1){​ inteface1.operation3();​ }}public class C {​ public void depend1(Interface1 inteface1){​ inteface1.operation1();​ }​ public void depend4(Interface1 inteface1){​ inteface1.operation4();​ }​ public void depend5(Interface1 inteface1){​ inteface1.operation5();​ }} 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D。如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。 按照接口隔离原则应当如下处理： 将接口Interface1拆分成几个接口（这里我们拆分成3个接口），类Ａ和类Ｃ分别与他们需要的接口建立依赖关系。 改造后：改进的UML类图如下： 改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public interface Interface1 {​ void operation1();}public interface Interface2 {​ void operation2();​ void operation3();}public interface Interface3 {​ void operation4();​ void operation5();}public class B implements Interface1,Interface2 {​ @Override​ public void operation1() {​ System.out.println(\"B 实现了operation1\");​ }​ @Override​ public void operation2() {​ System.out.println(\"B 实现了operation2\");​ }​ @Override​ public void operation3() {​ System.out.println(\"B 实现了operation3\");​ }}public class D implements Interface1,Interface3 {​ @Override​ public void operation1() {​ System.out.println(\"D 实现了operation1\");​ }​ @Override​ public void operation4() {​ System.out.println(\"D 实现了operation4\");​ }​ @Override​ public void operation5() {​ System.out.println(\"D 实现了operation5\");​ }}public class A {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend2(Interface2 inteface){​ inteface.operation2();​ }​ public void depend3(Interface2 inteface){​ inteface.operation3();​ }}public class C {​ public void depend1(Interface1 inteface){​ inteface.operation1();​ }​ public void depend4(Interface3 inteface){​ inteface.operation4();​ }​ public void depend5(Interface3 inteface){​ inteface.operation5();​ }} 测试代码如下： 12345678910111213141516171819202122public static void main(String[] args) {​ A a = new A();​ a.depend1(new B()); //A 类通过接口去依赖(使用)B​ a.depend2(new B());​ a.depend3(new B());​ C c = new C();​ c.depend1(new D());//C 类通过接口去依赖(使用)D​ c.depend4(new D());​ c.depend5(new D());​ } 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/05/17/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"},{"title":"算法前言","text":"根据up主小齐的经验，她的第一阶段是根据MIT的算法导论课的课程顺序调整Leetcode的刷题顺序的，如下就是该课程的排课表： 截止到目前[20200519]，杰哥已经刷了13道题了（easy难度，题号从小到大的排序），还是比较弱鸡的。杰哥也会根据这个排课表重新调整刷题顺序的，需要继续努力啊，少年。 第一阶段刷题： 数组： Leetcode no.53 最大子序和 Leetcode no.66 加1 2020年06月01日加入了 91算法群,和小伙伴一起刷算法题。以下是每天刷题记录: 数组、栈、队列： 2020-06-01 - 66. 加一 2020-06-02 - 75. 颜色分类 2020-06-03 - 1381. 设计一个支持增量操作的栈 2020-06-04 - 394. 字符串解码 2020-06-05 - 232. 用栈实现队列 2020-06-06 - 380. 常数时间插入、删除和获取随机元素 链表： 2020-06-07 - 206. 反转链表 2020-06-08 - 430. 扁平化多级双向链表 2020-06-09 - 109. 有序链表转换二叉搜索树 2020-06-10 - 160. 相交链表 2020-06-11 - 142. 环形链表 II 2020-06-12 - 146. LRU缓存机制 树： 2020-06-13 - 104. 二叉树的最大深度 2020-06-14 - 100. 相同的树 2020-06-15 - 129. 求根到叶子节点数字之和 2020-06-17 - 513. 找树左下角的值 2020-06-17 - 105. 从前序与中序遍历序列构造二叉树 2020-06-19 - 124. 二叉树中的最大路径和 哈希表： 2020-06-19 - 1. 两数之和 2020-06-20 - 447. 回旋镖的数量 2020-06-21 - 36. 有效的数独 2020-06-22 - 645. 错误的集合 2020-06-24 - 面试题 04.01. 节点间通路 2020-06-24 - 149. 直线上最多的点 双指针： 2020-06-25 - 11. 盛最多水的容器 2020-06-26 - 875. 爱吃香蕉的珂珂 2020-06-27 - 26. 删除排序数组中的重复项 2020-06-28 - 167. 两数之和II-输入有序数组 2020-06-29 - 42. 接雨水 2020-06-30 - 面试题 17.11. 单词距离 进阶篇： 2020-07-04 - 581. 最短无序连续子数组 2020-07-05 - 78. 子集 2020-07-06 - 62. 不同路径 2020-07-07 - 20. 有效的括号 | 32. 最长有效括号 2020-07-08 - 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 2020-07-08 - 206. 反转链表 | 92. 反转链表 II | 25. K 个一组翻转链表 2020-07-10 - 144. 二叉树的前序遍历 | 94. 二叉树的中序遍历 | 145. 二叉树的后序遍历 | 102. 二叉树的层序遍历 2020-07-11 - 208. 实现Trie 2020-07-12 - 677. 键值映射 2020-07-13 - 面试题17.17 多次搜索 2020-07-14 - 547. 朋友圈 2020-07-15 - 924. 尽量减少恶意软件的传播 2020-07-16 - 1319. 连通网络的操作次数","link":"/2020/05/19/%E7%AE%97%E6%B3%95%E5%89%8D%E8%A8%80/"},{"title":"数组_66加一","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例&nbsp;1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例&nbsp;2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 Related Topics数组 1234567891011121314public int[] plusOne(int[] digits) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; digits.length; i++) { sb.append(digits[i]); } String s = sb.toString(); BigDecimal value = new BigDecimal(s); char[] chars = String.valueOf(value.add(new BigDecimal(1))).toCharArray(); int[] sum = new int[chars.length]; for (int i = 0; i &lt; chars.length; i++) { sum[i] = ( chars[i]-'0'); } return sum;} 这是我原来三天前的思路。想转成整数然后相加，把计算交给程序，奈何随着输入的数组长度越来越长，总是会溢出，然后我看了思路，觉得自己太傻，就为了自己省事，唉，在做算法题啊。 以下是我看完思路后，三天后独立完成的。 1234567891011121314151617public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i &gt;= 0; i--) { if (digits[i]+1&lt;10){ digits[i]=digits[i]+1; break; }else { digits[i]=0; } } if (digits[0] == 0) { int[] ints = new int[digits.length + 1]; ints[0]=1; return ints; } return digits; }","link":"/2020/05/21/%E6%95%B0%E7%BB%84_66%E5%8A%A0%E4%B8%80/"},{"title":"设计模式前言","text":"设计模式：软件工程中，设计模式 是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由Erich Gamma 等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式的目的： 代码重用性 可读性 可扩展性 可靠性 使程序呈现高内聚，低耦合的提醒 设计模式包含了对象的精髓，” 懂了设计模式，你就懂了面向对象分析和设计的精要 “ 设计模式七个原则： 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则 ocp 迪米特法则 合成复用原则 设计模式分类设计模式分为三种类型，共23种 创建型模式：单例模式、工厂方法模式、抽象工厂模式、原型模式、建造者模式 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式 行为型模式：模板方法模式、命令模式访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注意 设计模式不是代码，而是某一类问题的通用解决方案 设计模式的本质是提高软件的维护性、通用性和扩展性，并降低软件的复杂度 设计模式不局限于某种语言，java、php、C++都有设计模式 UML科普文 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%8D%E8%A8%80/"},{"title":"迪米特法则","text":"基本介绍 一个对象应该对其他对象保存最少的了解 类与类关系越密切，耦合度越大 迪米特法则(Demeter Principle) 又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。 迪米特法则还有一个更加简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的关系很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也是就是说，陌生的类最好不要以局部变量的形式出现在类的内部中。 代码例子： 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id 反例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//学院的员工类public class CollegeEmployee { private String id; public String getId() { return id; } public void setId(String id) { this.id = id; }}//学校的员工类public class Employee { private String id; public String getId() { return id; } public void setId(String id) { this.id = id; }}//学院管理类public class CollegeManager { public List&lt;CollegeEmployee&gt; getAllEmployee(){ List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(\"学院员工id=\" + i); list.add(collegeEmployee); } return list; }}//学校管理类public class SchoolManager { public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Employee employee = new Employee(); employee.setId(\"学校总部iD=\"+i); employees.add(employee); } return employees; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(CollegeManager sub){ //1.这里的CollegeEmployee 不是SchoolManager的直接朋友 //1.CollegeEmployee 是以局部变量的方式出现在SchoolManager中，不符合迪米特法则 //获取学院的员工 List&lt;CollegeEmployee&gt; allEmployee = sub.getAllEmployee(); for (CollegeEmployee e:allEmployee ) { System.out.println(e.getId()); } //获取学校的员工 List&lt;Employee&gt; allEmployee1 = this.getAllEmployee(); for (Employee e : allEmployee1) { System.out.println(e.getId()); } }}//打印public class Demeter1 { public static void main(String[] args) { SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmp(new CollegeManager()); }} 代码64行，CollegeEmployee 不是SchoolManager的直接朋友，它是以局部变量的方式出现在SchoolManager中，不符合迪米特法则。 改进：思路：我们只需要将打印学院员工编号的逻辑移到CollegeManager ，然后 SchoolManager 再调用CollegeManager的打印方法即可。这样就符合迪米特法则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//学院管理类public class CollegeManager { public List&lt;CollegeEmployee&gt; getAllEmployee(){ List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(\"学院员工id=\" + i); list.add(collegeEmployee); } return list; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(){ List&lt;CollegeEmployee&gt; allEmployee = getAllEmployee(); for (CollegeEmployee e:allEmployee ) { System.out.println(e.getId()); } }}//学校管理类public class SchoolManager { public List&lt;Employee&gt; getAllEmployee(){ List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Employee employee = new Employee(); employee.setId(\"学校总部iD=\"+i); employees.add(employee); } return employees; } //该方法完成输出学校总部和学院员工信息（id） public void printAllEmp(CollegeManager sub){ sub.printAllEmp(); //获取学校的员工 List&lt;Employee&gt; allEmployee1 = this.getAllEmployee(); for (Employee e : allEmployee1) { System.out.println(e.getId()); } }} 迪米特法则注意事项和细节： 迪米特法则的核心是降低类之间的耦合 但是注意：迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完成没有依赖关系 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/06/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"},{"title":"网易面试题：超过班级百分之几","text":"有一个班级有&nbsp;n 个人，给出&nbsp;n 个元素，第&nbsp;i 个元素代表 第&nbsp;i 位同学的考试成绩，接下进行&nbsp;m 次询问，每次询问给出一个数值&nbsp; t ，表示第&nbsp;t 个同学，然后需要我们输出第 &nbsp;t 个同学的成绩超过班级百分之几的人，百分数&nbsp;p 可以这样算：p = (不超过第 t 个同学分数的人数 ) / n * 100%。输出的时候保留到小数点后 6 位，并且需要四舍五入。 输入描述：第一行输入两个数&nbsp;n 和&nbsp;m ，两个数以空格隔开，表示 &nbsp;n 个同学和&nbsp; m 次询问。第二行输入 &nbsp;numns1 个数值 &nbsp;ni，表示每个同学的分数，第三行输入&nbsp; m 个数值&nbsp;mi，表示每次询问是询问第几个同学。（注意，这里 2&lt;=&nbsp;n，&nbsp;m&lt;=100000，0&lt;=&nbsp;ni&lt;=150，1&lt;=&nbsp;mi&lt;=&nbsp;n） 输出描述：输出&nbsp;m 行，每一行输出一个百分数&nbsp;p ，代表超过班级百分之几的人。 示例: 输入: 3 2 50 60 70 1 2 输出: 33.333333% 66.666667% 时间复杂度O(n), n 位学生数量 空间复杂度O(1) 12345678910111213141516171819202122232425public String[] getPercentArray(int[] personsAndCount, int[] score, int[] indexs) { int persons = personsAndCount[0]; int count = personsAndCount[1]; int[] allscores = new int[151]; int[] exceedPersonsByScore = new int[151]; String[] values = new String[count]; int sum = 0; //get the every score person count for (int i = 0; i &lt; persons; i++) { allscores[score[i]] += 1; } //get the every score exceed person count for (int i = 0; i &lt; 151; i++) { sum += allscores[i]; exceedPersonsByScore[i] = sum; } for (int i = 0; i &lt; count; i++) { int exceedPersons = exceedPersonsByScore[score[indexs[i] - 1]]; BigDecimal value = new BigDecimal(exceedPersons).multiply(new BigDecimal(100)).divide(new BigDecimal(persons), 6, RoundingMode.HALF_UP); values[i] = value.toString() + \"%\"; } return values;} [91算法打卡第三十九天参考答案](https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md)","link":"/2020/07/09/%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E9%A2%98_%E8%B6%85%E8%BF%87%E7%8F%AD%E7%BA%A7%E7%99%BE%E5%88%86%E4%B9%8B%E5%87%A0/"},{"title":"里氏替换原则","text":"OO中的继承性的思考和说明 继承包含这样一层含义： 父类中凡是已经实现好的方法，实际上是在设计规范，虽然它不强制要求所有子类必须遵循这些规范，但是如果子类如果对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。 继承给程序设计带来便利的同时，也带来了弊端。比如使用了继承，父类的任何改动都得考虑到所有继承的子类，并且父类修改后，所有涉及到的子类功能都有可能产生故障。 问题提出：如何正确使用继承？ 里氏替换原则 基本介绍 里氏替换原则（Liskov Substitution Principle）在1988年，由麻省理工学院的一位姓里的女士提出的。 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方都必须能透明地使用其子类对象。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 反例：12345678910111213141516171819202122232425262728293031323334public class A { //a + b public Integer function1(int a,int b){ return a + b; }}public class B extends A{ //change function1 of A by accident @Override public Integer function1(int a, int b) { return a-b; }}public class Main { public static void main(String[] args) { A a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); A b = new B(); System.out.println(\"1+2=\"+b.function1(1, 2)); //没想到B 已经改了继承的方法，造成结果错误 System.out.println(\"2+3=\"+b.function1(2, 3)); }} 测试结果： 解决方法： B类不小心改了A类的方法，导致调用出错。在实际开发中，我们常常会通过修改父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系复用性比较差。 通用的做法是：将原来的父类和子类都继承一个更加通用的基类，原有的继承关系去掉，采用依赖，聚合，组合等方式代替。 改进后的方案如下： 正例：123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Base { public abstract Integer function1(int a, int b);}public class A extends Base{ //a + b @Override public Integer function1(int a,int b){ return a + b; }}public class B extends Base { A a = new A(); //a-b @Override public Integer function1(int a, int b) { return a-b; } public Integer function2(int i, int j){ return a.function1(i, j); }}public class Main { public static void main(String[] args) { Base a = new A(); System.out.println(\"1+2=\"+a.function1(1, 2)); System.out.println(\"2+3=\"+a.function1(2, 3)); System.out.println(\"-------------------------\"); Base b = new B(); System.out.println(\"1-2=\"+b.function1(1, 2)); System.out.println(\"2-3=\"+b.function1(2, 3)); }} 总之，里氏替换原则告诉我们，子类中尽量不要重写父类的方法！ 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》","link":"/2020/05/23/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"},{"title":"面试题 04.01. 节点间通路","text":"节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 示例1: 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2 输出：true 示例2: 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4 输出 true 提示： 节点数量n在[0, 1e5]范围内。 节点编号大于等于 0 小于 n。 图中可能存在自环和平行边。 Related Topics图 昨天看了宝石的题解，今天再自己做出来了，fighting。用了邻接表+DFS时间复杂度：构建邻接表：O(n) n为边的总数DFS：O(n+m) n为去除平行边和自环边的总数，m为点数空间复杂度：visited数组：O(m) m为点数邻接表：O(n+m) n为去除自环边的总数，m为点数dfs：O(m) 递归栈的最大深度，m为点数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Map&lt;Integer, Set&lt;Integer&gt;&gt; integerSetMap ;BitSet bitSet;private void transferMapFromGraph(int[][] graph){ integerSetMap=new HashMap&lt;&gt;(); for (int i = 0; i &lt; graph.length; i++) { int[] edge = graph[i]; Set&lt;Integer&gt; pointSet = integerSetMap.getOrDefault(edge[0], new HashSet&lt;&gt;()); pointSet.add(edge[1]); integerSetMap.put(edge[0], pointSet); }}private boolean dfs(int start, int target) { if (!integerSetMap.containsKey(start)){ return false; } if (start == target) { return true; } bitSet.set(start); Set&lt;Integer&gt; pointSet = integerSetMap.get(start); Iterator&lt;Integer&gt; iterator = pointSet.iterator(); while (iterator.hasNext()) { Integer next = iterator.next(); if(next==target){ return true; } if (bitSet.get(next)){ continue; } if (dfs(next, target)) { return true; } } return false;}public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) { if (n &lt; 1) { return false; } transferMapFromGraph(graph); bitSet = new BitSet(n); return dfs(start, target);} 91算法打卡第二十三天参考答案","link":"/2020/06/24/%E9%9D%A2%E8%AF%95%E9%A2%980401_%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/"},{"title":"面试题 17.11. 单词距离","text":"有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗? 示例： 输入：words = [&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,&quot;from&quot;,&quot;a&quot;,&quot;university&quot;,&quot;in&quot;,&quot;a&quot;,&quot;city&quot;], word1 = &quot;a&quot;, word2 = &quot;student&quot; 输出：1 提示： words.length &lt;= 100000 Related Topics双指针字符串 第一种方法的伪代码： 先遍历数组，当数组中的值等于word1或word2，就创建一个pair，key为当前值，value为当前值的索引，然后放入list中。 获取list的第一个元素，记做pre。初始化最小差值minPath，值初始化为超大超大那种。。。 跳过list的第一个元素，从第二个元素开始遍历： 记当前的遍历元素为cur 当pre的key和cur的key 不一样，得出pre和cur的value 差值 path，并与minPath求最小值，赋值到minPath。 cur赋值给pre 继续循环。 返回minPath 时间复杂度O(n),空间复杂度O(n) 1234567891011121314151617181920212223public int findClosest(String[] words, String word1, String word2) { List&lt;Pair&gt; pairs = new ArrayList&lt;&gt;(); int minPath = Integer.MAX_VALUE; for (int i = 0; i &lt; words.length; i++) { if (word1.equals(words[i]) || word2.equals(words[i])) { Pair&lt;String, Integer&gt; stringIntegerPair = new Pair&lt;String, Integer&gt;(words[i], i); pairs.add(stringIntegerPair); } } if (pairs.size() &lt; 2) { return minPath; } Pair prePair = pairs.get(0); for (int i = 1; i &lt; pairs.size(); i++) { Pair curPair = pairs.get(i); if (!prePair.getKey().equals(curPair.getKey())) { int path = Math.abs((int) curPair.getValue() - (int) prePair.getValue()); minPath = Math.min(path, minPath); } prePair = curPair; } return minPath;} 第二种方法是看题解的，看了之后觉得我的第一种方法有点多此一举，其实可以不需要维护list的。。。 时间复杂度O(n),空间复杂度O(1) 123456789101112131415161718public int findClosest(String[] words, String word1, String word2) { int minPath = Integer.MAX_VALUE; Integer word1Index = null; Integer word2Index = null; for (int i = 0; i &lt; words.length; i++) { if (word1.equals(words[i])) { word1Index = i; } if (word2.equals(words[i])) { word2Index = i; } if (word1Index != null &amp;&amp; word2Index != null) { minPath=Math.min(minPath,Math.abs(word1Index-word2Index)); } } return minPath;} 91算法打卡第三十天参考答案","link":"/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%9817_11_%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/"},{"title":"面试题17.17 多次搜索","text":"给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。 示例： 输入： big = &quot;mississippi&quot; smalls = [&quot;is&quot;,&quot;ppi&quot;,&quot;hi&quot;,&quot;sis&quot;,&quot;i&quot;,&quot;ssippi&quot;] 输出： [[1,4],[8],[],[3],[1,4,7,10],[5]] 提示： 0 &lt;= len(big) &lt;= 1000 0 &lt;= len(smalls[i]) &lt;= 1000 smalls的总字符数不会超过 100000。 你可以认为smalls中没有重复字符串。 所有出现的字符均为英文小写字母。 Related Topics字典树字符串 时间复杂度 建树 O(n*m)，n为短单词的个数，m为短单词的平均长度 搜索 O(S*N)，S为长单词的长度，N为每次长单词的子单词的命中次数。 空间复杂度 建树O(m*n)，m为字符集中所占的 字符个数，n为 短单词的个数 搜索 O(n)，n为命中的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution { public int[][] multiSearch(String big, String[] smalls) { if (big == null || smalls == null) { return null; } Trie trie = new Trie(); trie.insert(smalls); int[][] wordSearchList = trie.getWordSearchList(big); return wordSearchList; }}class Trie{ Trie[] next; boolean end; int index; int wordSize; public Trie() { this.next = new Trie[26]; this.end = false; this.index = -1; this.wordSize = -1; } public void insert(String[] words) { this.wordSize = words.length; for (int i = 0; i &lt; words.length; i++) { insertWordAndIndex(words[i], i); } } private void insertWordAndIndex(String word, int index) { Trie curTrie = this; char[] chars = word.toCharArray(); for (int i = 0; i &lt; chars.length; i++) { int charIndex = chars[i] - 'a'; if (curTrie.next[charIndex] == null) { curTrie.next[charIndex] = new Trie(); } curTrie = curTrie.next[charIndex]; } curTrie.end = true; curTrie.index = index; } public int[][] getWordSearchList(String word) { List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(this.wordSize); for (int i = 0; i &lt; this.wordSize; i++) { list.add(new ArrayList&lt;&gt;()); } for (int i = 0; i &lt; word.length(); i++) { String curWord = word.substring(i); Trie curTrie = this; char[] chars = curWord.toCharArray(); for (int j = 0; j &lt; chars.length; j++) { int charIndex = chars[j] -'a'; if (curTrie.next[charIndex] != null) { curTrie = curTrie.next[charIndex]; }else{ break; } if (curTrie.end) { List&lt;Integer&gt; subList = list.get(curTrie.index); subList.add(i); } } } // int[line][column] tips int[][] results = new int[list.size()][]; for (int i = 0; i &lt; list.size(); i++) { List&lt;Integer&gt; subList = list.get(i); results[i]=new int[subList.size()]; for (int j = 0; j &lt; subList.size(); j++) { results[i][j] = subList.get(j); } } return results; }} 91算法打卡第四十三天参考答案","link":"/2020/07/13/%E9%9D%A2%E8%AF%95%E9%A2%9817_17_%E5%A4%9A%E6%AC%A1%E6%90%9C%E7%B4%A2/"},{"title":"单例模式","text":"基本介绍单例模式确保一个类只有一个实例，并提供一个全局访问点。 比如Hibernate的SessionFactory，它就充当数据存储源的代理，并负责创建Session对象，SessionFactory并不是轻量级的，一般情况下，一个项目只需要一个SessionFactory就够了。这时就会使用到单例模式。 单例设计模式七种模式 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（双重检查） 静态内部类 枚举 饿汉式（静态常量）—— 推荐步骤如下： 构造器私有化（防止new） 类的内部创建对象 对外暴露一个静态的公共方法。getInstance 代码实现如下： 1234567891011121314public class Singleton { //1. 构造器私有化（防止new） private Singleton(){ } //2. 类的内部创建对象 private final static Singleton instance = new Singleton(); //3. 对外暴露一个静态的公共方法。getInstance public static Singleton getInstance(){ return instance; }} 优缺点如下： 优点： 这种方法比较简单，就是在类加载的时候就完成实例化。避免了线程同步的问题。 缺点： 在类加载的时候就完成实例化，没有达到懒加载的效果。如果从始至终都没有用到这个实例，就会造成内存的浪费。 补充说明： 这种方法基于类加载机制避免了多线程的同步问题，不过，instance 在类加载时就实例化，在单例模式多数都是调用getInstance方法。但是导致类加载的原因有很多，因此不能确定有其他方式（或者其他静态方法）导致类加载，这时候初始化instance就没有达到懒加载的效果。 结论：这种单例模式方法可用，可能会造成内存浪费。 饿汉式（静态代码块）—— 推荐12345678910111213141516171819public class Singleton { //1. 构造器私有化（防止new） private Singleton(){ } //2. 类的内部创建对象 private static Singleton instance ; //在静态代码块中，创建单例对象 static { instance = new Singleton(); } //3. 对外暴露一个静态的公共方法。getInstance public static Singleton getInstance(){ return instance; }} 这种方式和上面的方式类似，只不过将类的实例化过程放在了静态代码块中，也是在类加载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面一致。 懒汉式（线程不安全）—— 不能使用1234567891011121314151617public class Singleton { //1. 构造器私有化（防止new） private Singleton() { } //2. 类的内部创建对象 private static Singleton instance; //3. 对外暴露一个静态的公共方法。getInstance public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 优缺点如下： 优点： 起到了懒加载的效果，但是只能在单线程下使用。 缺点： 如果在多线程下使用，可能会产生多个实例对象。所以在多线程环境下不能使用这种方式。 结论： 实际开发中，不要使用这种方式。 懒汉式（线程安全，同步方法）—— 不推荐1234567891011121314151617public class Singleton { //1. 构造器私有化（防止new） private Singleton() { } //2. 类的内部创建对象 private static Singleton instance; //3. 对外暴露一个静态的公共方法。getInstance public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 优缺点如下： 解决了线程安全问题 效率太低。每个线程在获得类的实例对象时，都要执行getInstance()方法进行同步。而这个方法只执行一次实例化代码就够了，后面的线程想获得该类实例，直接return就可以了。在方法上进行同步效率太低 结论：实际开发中，不推荐这种方式 懒汉式（双重检查）—— 推荐123456789101112131415161718192021public class Singleton { //1. 构造器私有化（防止new） private Singleton() { } //2. 类的内部创建对象 private volatile static Singleton instance; //3. 对外暴露一个静态的公共方法。getInstance public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 优缺点如下： 优点： 双重检查（Double-Check）概念是多线程开发中常使用的，这样子能保证线程安全。 优点： 线程安全；延迟加载；效率较高 volatile关键字确保： 当instance变量被初始化成Singleton实例时，多个线程正确处理instance变量。同时防止指令重排。volatile关键字要确保在JDK1.4版本后使用。 结论： 在实际开发中，推荐使用这种单例设计模式 静态内部类 —— 推荐12345678910111213141516public class Singleton { //1. 构造器私有化（防止new） private Singleton() { } //2.写一个静态内部类，该类有一个静态属性 Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } //3. 对外暴露一个静态的公共方法。直接返回SingletonInstance.INSTANCE public static Singleton getInstance() { return SingletonInstance.INSTANCE; }} 优缺点如下： 静态内部类在Singleton类被加载时并不会立即实例化，而是在需要Singleton实例时，调用getInstance方法，才会加载SingletonInstance类，从而完成静态对象INSTANCE的创建，这点同饿汉模式。 这种方式采用了类加载机制来保证初始化实例时只有一个线程。虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。如果在一个类的clinit()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行clinit()方法后，其他线程唤醒之后不会再次进入clinit()方法。同一个加载器下，一个类型只会初始化一次)，在实际应用中，这种阻塞往往是很隐蔽的。故而，可以看出INSTANCE在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。 优点： 避免了线程不安全，利用静态内部类的特点实现延迟加载，效率高 缺点：静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，设计单例时，我们要根据实际情况决定使用哪种方式。 结论： 在实际开发中，如果不需要传参数，推荐使用这种单例设计模式 枚举 —— 推荐123456789public enum Singleton { INSTANCE; public void doSometing() { }} 优缺点： 借助枚举来实现单例模式。不仅能避免多线程同步的问题，而且还能防止反序列化重新创建新的对象。 这种方式在《Effective Java》中提倡使用 结论： 推荐使用 单例模式在JDK中的应用在JDK中，java.lang.Runtime就是经典的单例设计模式（饿汉式（静态常量））。 代码如下： 单例模式注意事项和细节说明 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类时，必须要记住使用对应的获取对象的方法，比如getInstance静态方法，而不是使用new。 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即重量级对象），但是又经常使用的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等） 代码地址：https://github.com/GilbertXiao/JavaDesignPatterns 参考资源: 韩顺平 《图解Java设计模式》 https://blog.csdn.net/mnb65482/article/details/80458571","link":"/2020/06/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"抽象工厂模式","text":"阅读本文之前，请先阅读《工厂方法模式》一文。 引文： 《工厂方法模式》一文的披萨项目又迎来重大升级了。现在披萨产品可以放各式各样的定制食材，如下图。 基本介绍 每一个模式都是针对一定问题的解决方案。抽象工厂模式面对的问题是多个产品等级结构的设计。 抽象工厂模式提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类。 抽象工厂模式是工厂方法模式的升级版，工厂方法模式针对的是一个产品等级结构（工厂模式一文的Pizza 产品等级），而抽象工厂模式针对的是多个产品等级结构（本文中的Cheese、Sauce、Viggies 产品等级）。 以本文的原料工厂为例，解释下产品族、产品等级结构 抽象工厂模式的组成 与工厂方法模式一样，使用抽象工厂模式的系统涉及以下的角色： 抽象工厂(Creator)角色：抽象工厂模式的核心，与应用程序无关。任何在抽象工厂模式中创建对象的工厂类 必须实现这个接口或者实现这个抽象类(如果抽象工厂角色是由抽象类实现的话)。 具体工厂(Concrete Creator) 角色：它含有与应用相关的逻辑，并且受到应用程序的调用从而创建产品对象。 抽象产品(Product)角色：它是抽象工厂模式所创建的对象的超类型，具体产品继承的父类或者是实现的接口。 具体产品(Concrete Product) 角色: 这个角色实现了抽象产品角色所声明的接口。抽象工厂模式所创建的每一个对象都是某个具体产品角色的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。 代码思路分析(类图) 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282//原料//cheesepublic interface Cheese {}//意大利白干酪public class MozzarellaCheese implements Cheese{}//韩国白干酪public class KoreaCheese implements Cheese{}public interface Sauce {}//番茄酱料public class TomatoSauce implements Sauce{}//超甜番茄酱料public class SweetTomatoSauce implements Sauce{}public interface Veggies {}//黑橄榄public class BlackOlive implements Veggies{}//黑胡椒public class BlackPepper implements Veggies{}//胡萝卜public class Carrot implements Veggies{}//茄子public class eggplant implements Veggies{}//大蒜public class Garlic implements Veggies{}//洋葱public class Onion implements Veggies{}//披萨草public class Oregano implements Veggies {}//红薯public class RedPotato implements Veggies{}//白胡椒public class WhitePepper implements Veggies {}//原料工厂接口 -- 抽象工厂模式public interface PizzaIngredientFactory { Sauce createSauce(); Cheese createCheese(); Veggies[] createVeggies();}//纽约原料工厂public class NYPizzaIngredientFactory implements PizzaIngredientFactory{ @Override public Sauce createSauce() { return new SweetTomatoSauce(); } @Override public Cheese createCheese() { return new KoreaCheese(); } @Override public Veggies[] createVeggies() { Veggies[] veggies = {new Garlic(),new Onion(),new Carrot(),new RedPotato(),new BlackPepper()}; return veggies; }}//芝加哥原料工厂public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory{ @Override public Sauce createSauce() { return new TomatoSauce(); } @Override public Cheese createCheese() { return new MozzarellaCheese(); } @Override public Veggies[] createVeggies() { Veggies[] veggies = {new Oregano(),new BlackOlive(),new eggplant(),new WhitePepper()}; return veggies; }}//pizzapublic abstract class Pizza { String name; Sauce sauce; Veggies[] veggies; Cheese cheese; //准备原材料，不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake(){ System.out.println(name + \" banking...\"); } public void cut(){ System.out.println(name + \" cutting...\"); } public void box(){ System.out.println(name + \" boxing...\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Pizza{\" + \"name='\" + name + '\\'' + \", sauce=\" + sauce + \", veggies=\" + Arrays.toString(veggies) + \", cheese=\" + cheese + '}'; }}public class CheesePizza extends Pizza{ PizzaIngredientFactory pizzaIngredientFactory; public CheesePizza(PizzaIngredientFactory pizzaIngredientFactory) { this.pizzaIngredientFactory = pizzaIngredientFactory; } @Override public void prepare() { sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese(); }}public class PepperPizza extends Pizza{ PizzaIngredientFactory pizzaIngredientFactory; public PepperPizza(PizzaIngredientFactory pizzaIngredientFactory) { this.pizzaIngredientFactory = pizzaIngredientFactory; } @Override public void prepare() { cheese = pizzaIngredientFactory.createCheese(); veggies = pizzaIngredientFactory.createVeggies(); }}public class VeggiePizza extends Pizza{ PizzaIngredientFactory pizzaIngredientFactory; public VeggiePizza(PizzaIngredientFactory pizzaIngredientFactory) { this.pizzaIngredientFactory = pizzaIngredientFactory; } @Override public void prepare() { sauce = pizzaIngredientFactory.createSauce(); veggies = pizzaIngredientFactory.createVeggies(); }}//Pizza store -- 原料工厂的客户端，pizza store使用了 工厂方法模式，详见工厂模式一文public interface PizzaStore { Pizza createPizza(String type);}public class NYPizzaStore implements PizzaStore{ private final static String CHEESE_PIZZA = \"cheese\"; private final static String VEGGIE_PIZZA = \"viggie\"; private final static String PEPPER_PIZZA = \"pepper\"; @Override public Pizza createPizza(String type) { Pizza pizza = null; PizzaIngredientFactory pizzaIngredientFactory = new NYPizzaIngredientFactory(); if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new CheesePizza(pizzaIngredientFactory); pizza.setName(\"New York Style Cheese Pizza\"); }else if(VEGGIE_PIZZA.equalsIgnoreCase(type)){ pizza = new VeggiePizza(pizzaIngredientFactory); pizza.setName(\"New York Style Veggie Pizza\"); }else if(PEPPER_PIZZA.equalsIgnoreCase(type)){ pizza = new PepperPizza(pizzaIngredientFactory); pizza.setName(\"New York Style Pepper Pizza\"); } return pizza; }}public class ChicagoPizzaStore implements PizzaStore { private final static String CHEESE_PIZZA = \"cheese\"; private final static String VEGGIE_PIZZA = \"viggie\"; private final static String PEPPER_PIZZA = \"pepper\"; @Override public Pizza createPizza(String type) { Pizza pizza = null; PizzaIngredientFactory pizzaIngredientFactory = new ChicagoPizzaIngredientFactory(); if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new CheesePizza(pizzaIngredientFactory); pizza.setName(\"Chicago Style Cheese Pizza\"); }else if(VEGGIE_PIZZA.equalsIgnoreCase(type)){ pizza = new VeggiePizza(pizzaIngredientFactory); pizza.setName(\"Chicago Style Veggie Pizza\"); }else if(PEPPER_PIZZA.equalsIgnoreCase(type)){ pizza = new PepperPizza(pizzaIngredientFactory); pizza.setName(\"Chicago Style Pepper Pizza\"); } return pizza; }}//Pizza Store 的客户端 和 测试方法public class OrderPizza { PizzaStore pizzaStore; public OrderPizza(PizzaStore pizzaStore) { this.pizzaStore = pizzaStore; } public Pizza orderPizza(String type){ Pizza pizza ; pizza = pizzaStore.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(new NYPizzaStore()); Pizza cheese = orderPizza.orderPizza(\"cheese\"); OrderPizza orderPizza1 = new OrderPizza(new ChicagoPizzaStore()); Pizza cheese1 = orderPizza1.orderPizza(\"cheese\"); }} 什么情况下应当使用抽象工厂模式 一个系统不应该依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 这个系统的产品有多于一个的产品族。 同属于同一个产品族的产品是在一起使用的，这个约束必须在系统的设计中体现出来。比如，纽约披萨用的是KoreaCheese、SweetTomatoSauce,这两个产品是在同一产品族下的。 参考资源: 《Java与模式》 《Head first 设计模式》","link":"/2020/07/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"工厂方法模式","text":"三种工厂模式基本介绍在创建类时，通常可以同时定义多个构造函数，然后让它们创建类的实例。然而，有的时候，客户代码虽然需要某个对象，却并不关心或者不需要关心这个对象究竟是由哪个类创建而来的，此时就可以使用工厂模式。 工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 工厂模式在《Java与模式》中分为三类： 简单工厂模式(Simple Factory) 工厂方法模式(Factory Method) 抽象工厂模式(Abstract Factory) 这三种模式从上到下逐步抽象，并且更具一般性。 GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式(Factory Method) 与抽象工厂模式 (Abstract Factory) 。将简单工厂模式(Simple Factory)看成 工厂方法模式的一种特例，两者归为一类。 这两种都可以。本文使用《Java与模式》的方法，不过将简单工厂模式归在工厂方法模式一文中介绍。 简单工厂模式(Simple Factory)引文： 有一个披萨的项目，要便于披萨种类的扩展，便于维护。 1. 披萨的种类很多，比如GreekPizza、CheesePizza等 2. 披萨的制作有 prepare、bake、cut、box 3. 完成披萨店订购功能使用传统方式完成 思路分析(类图) 编写一个OrderPizza类，去订购需要的各种Pizza 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public abstract class Pizza { String name; //准备原材料，不同的披萨不一样，因此，我们做成抽象方法 abstract void prepare(); void bake(){ System.out.println(name + \" banking...\"); } void cut(){ System.out.println(name + \" cutting...\"); } void box(){ System.out.println(name + \" boxing...\"); } public String getName() { return name; } public void setName(String name) { this.name = name; }}public class CheesePizza extends Pizza { @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给制作奶酪披萨 准备原材料 \"); }}public class GreekPizza extends Pizza { @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给希腊披萨 准备原材料 \"); }}public class OrderPizza { private final static String CHEESE_PIZZA = \"cheese\"; private final static String GREEK_PIZZA = \"greek\"; public OrderPizza(String type){ Pizza pizza = null; if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new CheesePizza(); } else if (GREEK_PIZZA.equalsIgnoreCase(type)) { pizza = new GreekPizza(); } pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); }} 传统方式的优缺点： 1)优点是比较好理解，简单易操作。2)缺点是违反了设计模式的开闭原则(OCP),即当我们给类增加新功能时，尽可能不修改客户端的代码 。比如，当我们增加一个Pizza类，只要是订购Pizza的代码都需要修改。 2)改进思路分析 如果有多个客户端采用如上的方式订购了Pizza,那么意味着只要新增或修改了Pizza类，多个客户端都需要做改动，否则报错。 改进：把创建Pizza对象封装到一个类中，这样我们有新的Pizz种类时，只需要修改该类即可。其他创建Pizza对象的代码就不需要修改了。这就是简单工厂模式的应用。 简单工厂模式 基本介绍： 简单工厂模式又称静态工厂方法模式，是工厂方法模式的一种特殊实现，也是工厂模式家族中最简单实用的模式。结构如下： 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738public class SimpleFactory { private final static String CHEESE_PIZZA = \"cheese\"; private final static String GREEK_PIZZA = \"greek\"; private final static String PEPPER_PIZZA = \"pepper\"; public Pizza createPizza(String type) { Pizza pizza = null; if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new CheesePizza(); } else if (GREEK_PIZZA.equalsIgnoreCase(type)) { pizza = new GreekPizza(); } else if (PEPPER_PIZZA.equalsIgnoreCase(type)) { pizza = new PepperPizza(); } return pizza; }}public class OrderPizza { SimpleFactory simpleFactory; public OrderPizza(SimpleFactory simpleFactory) { this.simpleFactory = simpleFactory; } public Pizza orderPizza(String type){ Pizza pizza ; pizza = simpleFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 优缺点： 1)优点： 简单工厂模式实现了对责任的分割。即工厂类专注于对产品类的创建，而客户端则不用直接创建产品对象，仅仅负责“消费”产品。 2)缺点： 当产品类有复杂的多层次等级结构时，工厂类只有它自己。以不变应万变，这是缺点之一。 工厂类集中了所有产品的创建逻辑，是一个无所不知的全能类。当该类不能正常工作时，所有产品都会受到影响。 简单工厂方法只是一定程度上支持开闭原则，比如每次有新增的产品类，客户端不用做修改，这符合开闭原则，但是工厂类就需要修改以适用变化，这一块就不符合开闭原则了。 源码应用： JDK中java.text.DateFormat 的 如下方法使用了简单工厂模式： 12345public final static DateFormat getDateInstance(int style){ return get(0, style, 2, Locale.getDefault(Locale.Category.FORMAT));} 工厂方法模式(Factory Method)引文： 披萨项目升级，需要各个不同地区口味的披萨，比如芝加哥风味的CheesePizza、芝加哥风味的greekPizza，纽约风味的CheesePizza、纽约风味的greekPizza。思路一： 使用简单工厂模式， 创建不同的简单工厂类， 比如 ChicagoPizzaSimpleFactory、 NYPizzaSimpleFactory 等等。从当前这个案例来说， 也是可以的， 但是考虑到项目的规模， 以及软件的可维护性、 可扩展性并不是特别好 思路二： 使用工厂方法模式。 工厂方法模式的引进： 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。 首先，在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做，这个核心类则变成一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 工厂方法模式的组成： 从上图可以看出，使用工厂方法模式的系统涉及以下的角色： 抽象工厂(Creator)角色：工厂方法模式的核心，与应用程序无关。任何在工厂方法模式中创建对象的工厂类 必须实现这个接口或者实现这个抽象类(如果抽象工厂角色是由抽象类实现的话)。 具体工厂(Concrete Creator) 角色：它含有与应用相关的逻辑，并且受到应用程序的调用从而创建产品对象。 抽象产品(Product)角色：它是工厂方法模式所创建的对象的超类型，具体产品继承的父类或者是实现的接口。 具体产品(Concrete Product) 角色: 这个角色实现了抽象产品角色所声明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。 代码思路分析(类图)： 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public interface PizzaStore { Pizza createPizza(String type);}public class ChicagoPizzaStore implements PizzaStore{ private final static String CHEESE_PIZZA = \"cheese\"; private final static String GREEK_PIZZA = \"greek\"; private final static String PEPPER_PIZZA = \"pepper\"; @Override public Pizza createPizza(String type) { Pizza pizza = null; if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new ChicagoGreekPizza(); } else if (GREEK_PIZZA.equalsIgnoreCase(type)) { pizza = new ChicagoGreekPizza(); } else if (PEPPER_PIZZA.equalsIgnoreCase(type)) { pizza = new ChicagoPepperPizza(); } return pizza; }}public class NYPizzaStore implements PizzaStore{ private final static String CHEESE_PIZZA = \"cheese\"; private final static String GREEK_PIZZA = \"greek\"; private final static String PEPPER_PIZZA = \"pepper\"; @Override public Pizza createPizza(String type) { Pizza pizza = null; if (CHEESE_PIZZA.equalsIgnoreCase(type)) { pizza = new NYGreekPizza(); } else if (GREEK_PIZZA.equalsIgnoreCase(type)) { pizza = new NYGreekPizza(); } else if (PEPPER_PIZZA.equalsIgnoreCase(type)) { pizza = new NYPepperPizza(); } return pizza; }}public abstract class Pizza { String name; //准备原材料，不同的披萨不一样，因此，我们做成抽象方法 abstract void prepare(); void bake(){ System.out.println(name + \" banking...\"); } void cut(){ System.out.println(name + \" cutting...\"); } void box(){ System.out.println(name + \" boxing...\"); } public String getName() { return name; } public void setName(String name) { this.name = name; }}public class ChicagoCheesePizza extends Pizza { public ChicagoCheesePizza() { super.name = \"ChicagoCheesePizza\"; } @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给制作ChicagoCheesePizza 准备原材料 \"); }}public class NYCheesePizza extends Pizza { public NYCheesePizza() { super.name = \"NYCheesePizza\"; } @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给制作NYCheesePizza 准备原材料 \"); }}public class OrderPizza { PizzaStore pizzaStore; public OrderPizza(PizzaStore pizzaStore) { this.pizzaStore = pizzaStore; } public Pizza orderPizza(String type){ Pizza pizza ; pizza = pizzaStore.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(new NYPizzaStore()); Pizza cheese = orderPizza.orderPizza(\"cheese\"); OrderPizza orderPizza1 = new OrderPizza(new ChicagoPizzaStore()); Pizza cheese1 = orderPizza1.orderPizza(\"cheese\"); }} 工厂方法在源码中的应用： Collection 接口为抽象工厂类，工厂方法为iterator()方法，返回一个Iterator类型的对象（抽象产品）。 List接口为抽象工厂类，工厂方法为listIterator()方法，返回一个ListIterator类型的对象（抽象产品）。 工厂方法模式VS简单工厂模式： 由上面我们可以看出在结构上两者区别是很明显的。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体的类上。工厂方法模式可以允许很多具体工厂类从抽象工厂类中将创建行为继承下来，从而可以成为多个简单工厂模式的综合。 工厂方法模式退化后可以变得很像简单工厂模式。如果确定系统里面只需要一个具体工厂类，不妨可以把抽象工厂类合并到具体工厂类，再不妨把工厂方法改成静态，从而得到简单工厂模式。 理想情况下，系统增加一个产品，那么只需要向系统增加这个这个产品类及对应的工厂类，没有改变客户端，也没有改变抽象工厂角色或者其他已有的具体工厂类。这完全支持开闭原则。 参考资源: 韩顺平 《图解Java设计模式》 《Java与模式》 《Head first 设计模式》","link":"/2020/07/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"刷算法题","slug":"刷算法题","link":"/tags/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/tags/tomcat%E6%BA%90%E7%A0%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"刷算法题","slug":"刷算法题","link":"/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"tomcat源码","slug":"tomcat源码","link":"/categories/tomcat%E6%BA%90%E7%A0%81/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}